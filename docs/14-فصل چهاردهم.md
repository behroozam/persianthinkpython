فصل ۱۴

فایل ها

این فصل به معرفی ایده برنامه های ماندگار (Persistent) که داده ها را به
صورت دائمی در حافظه ذخیره سازی میکنند اختصاص دارد وهمچنین روش های مختلف
استفاده از حافظه ی دائمی (مثل فایل ها و پایگاه داده) را نشان میدهد.

۱۴.۱ ماندگاری

بیشتر برنامه هایی که ما تابحال دیده ایم گذرا بوده اند، به این معنا که
برای زمان کوتاهی اجرا میشده اند و خروجی خود را چاپ میکرده اند، اما وقتی
اجرای آنها تمام میشود، داده آنها از بین میرود. اگر شما دوباره آن برنامه
را اجرا کنید، آن برنامه در یک محیط تازه شروع به کار میکند.

بقیه برنامه ها ماندگار هستند: برای زمان زیادی (یا همیشه) اجرا میشوند؛
آنها حداقل بخشی از داده خود را در حافظه دائمی (برای مثال دیسک سخت) نگه
داری میکنند؛ و اگر آن برنامه ها بسته شده و دوباره شروع شوند، دوباره از
همانجایی که متوقف شده اند شروع به کار میکنند.

مثال هایی از برنامه های ماندگار سیستم های عامل هستند، وقتی کامپیوتر روشن
است به خوبی کار میکنند، و وبسرورها ، که همیشه در حال کارکردن هستند، و
منتظرند تا درخواستی از شبکه دریافت شود.

یکی از آسان ترین راه های مورد استفاده توسط برنامه ها برای نگهداری داده
هایشان خواندن و نوشتن در فایل های متنی است. ما قبلا برنامه هایی را دیده
ایم که محتویات یک فایل متنی را میخوانند؛ در این فصل ما برنامه هایی را
خواهیم دید که محتوایی را در فایل های متنی مینویسند.

یک جایگزین میتواند ذخیره وضعیت یک برنامه در پایگاه داده باشد. در این فصل
من یک پایگاه داده و یک ماژول pickle را آماده کرده ام که نگهداری داده های
برنامه را آسان میکند.

۱۴.۲ خواندن و نوشتن

یک فایل متنی یک دنباله از کاراکترها است که بر روی یک واسط مثل یک دیسک
سخت، فلش مموری یا دیسک نوری ذخیره میشود. ما نحوه ی باز کردن و خواندن یک
فایل را در بخش ۹.۱ دیده ایم.

برای نوشتن یک فایل ، شما باید با مد ‘w’ به عنوان پارامتر دوم آن را باز
کنید :

&gt;&gt;&gt; fout = open('output.txt', ‘w')

اگر یک فایل قبلا وجود داشته باشد، باز کردن آن با حالت نوشتن داده قبلی را
پاک میکند و از نو شروع به نوشتن میکند؛ پس مراقب باشید! اگر فایل وجود
نداشته باشد، یک فایل جدید ایجاد میشود.

open یک آبجکت فایل برمیگرداند که متد هایی برای کار با فایل فراهم میکند.
متد write داده ها را درون فایل مینویسد:

&gt;&gt;&gt; line1 = "This here's the wattle,\\n"

&gt;&gt;&gt; fout.write(line1)

24

مقدار بازگشتی عدد کاراکتر وارد شده است. آبجکت فایل میداند که هم اکنون در
کجا قرار دارد، پس اگر دوباره متد write را صدا بزنید ، آن متد داده های
جدید را به انتهای فایل اضافه خواهد کرد.

&gt;&gt;&gt; line2 = "the emblem of our land.\\n"

&gt;&gt;&gt; fout.write(line2)

24

وقتی کار نوشتن شما به اتمام رسید ، شما باید فایل را ببندید.

&gt;&gt;&gt; fout.close()

اگر شما فایل را نبندید، خود در پایان برنامه بسته میشود.

۱۴.۳ عملگر فرمت

آرگومان write باید یک رشته باشد ، پس اگر بخواهیم مقادیر دیگری را در فایل
قرار دهیم ، باید آنها را به رشته تغییر دهیم. راحتترین راه برای انجام این
کار با دستور str میباشد:

&gt;&gt;&gt; x = 52

&gt;&gt;&gt; fout.write(str(x))

یک جایگزین استفاده از عملگر فرمت (%) است. وقتی این اپراتور روی اعداد
صحیح اعمال شود، % اپراتور پیمانه \[باقیمانده\] است. اما وقتی اولین
عملوند رشته باشد ، % اپراتور فرمت است.

اولین عملوند رشته فرمت است، که دربردارنده ی یک یا بیشتر دنباله ی فرمت
است، و چگونگی فرمت عملوند دوم را مشخص میکند.

برای مثال ، دنباله ی فرمت ‘d%’ به معنی این است که عملوند دوم باید به شکل
عدد صحیح دهدهی فرمت شود.

&gt;&gt;&gt; camels = 42

&gt;&gt;&gt; '%d' % camels

'42'

نتیجه رشته ‘42’ که نباید با عدد صحیحی با مقدار ۴۲ اشتباه گرفته شود.

یک دنباله فرمت میتواند هر جایی در زشته ظاهر شود، بنابر این شما میتوانید
یک مقدار را درون یک رشته قرار دهید:

&gt;&gt;&gt; 'I have spotted %d camels.' % camels

'I have spotted 42 camels.'

اگر بیش از یک دنباله فرمت در یک رشته وجود داشته باشد، دومین آرگومان باید
یک چندتایی باشد. هر دنباله فرمت باید به ترتیب با یکی از اعضای چندتایی
سازگار شود.

مثالی بعد از ‘d%’ برای فرمت یک عدد صحیح، از ‘g%’ برای فرمت یک عدد
اعشاری، و از ‘s%’ برای فرمت یک رشته استفاده میکند:

&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')

'In 3 years I have spotted 0.1 camels.'

تعداد عناصر در یک چندتایی باید با تعداد دنباله های فرمت در یک رشته برابر
باشد. همچنین، نوع عناصر باید با دنباله های فرمت سازگار باشد.

&gt;&gt;&gt; '%d %d %d' % (1, 2)

TypeError: not enough arguments for format string

&gt;&gt;&gt; '%d' % 'dollars'

TypeError: %d format: a number is required, not str

در مثال اول، تعداد کافی عنصر وجود ندارد؛ در مثال دوم ، نوع عنصر اشتباه
است.

برای اطلاعات بیشتر درمورد عملگر فرمت ، این لینک را مشاهده فرمایید
https://docs.python.org/3/library/
stdtypes.html\#printf-style-string-formatting

یک جایگزین قدرتمند متد string format است ، که میتوانید در
https://docs.python.org/3/ library/stdtypes.html\#str.format درمورد آن
مطالعه کنید.

۱۴.۴ نام و مسیر فایل ها

فایل ها در دایرکتوری ها ( فولدر ها ) سازمان میابند. هر برنامه در حال
اجرا یک “دایرکتوری فعلی” دارد، که دایرکتوری پیشفرض برای بیشتر عملیات
هاست. برای مثال ، وقتی شما یک فایل را برای عملیات خواندن باز میکنید،
پایتون در دایرکتوری فعلی به دنبال آن میگردد.

ماژول os توابعی برای کار بار فایل ها و دایرکتوری ها فراهم میکند (نام os
مخفف عبارت operating system به معنای سیستم عامل است). متد os.getcwd نام
دایرکتوری فعلی را برمیگرداند :

&gt;&gt;&gt; import os

&gt;&gt;&gt; cwd = os.getcwd()

&gt;&gt;&gt; cwd

'/home/dinsdale'

cwd مخفف “current working directory” به معنای دایرکتوری کاری جاری
میباشد. در این مثال نتیجه /home/dinsdale است که دایرکتوری home کاربری با
نام dinsdale است.

یک رشته مانند '/home/dinsdale' که فایل یا دایرکتوری جاری را مشخص میکند
مسیر (path) نام دارد.

یک نام فایل ساده ، مثل memo.txt هم به عنوان یک مسیر درنظر گرفته میشود،
اما یک مسیر نسبی ، زیرا نسبت به دایرکتوری فعلی مسیر را مشخص میکند. اگر
دایرکتوری فعلی /home/dinsdale باشد ، نام فایل memo.txt به
/home/dinsdale/memo.txt اشاره میکند.

یک مسیر که با / شروع میشود به دایرکتوری فعلی وابسته نیست ؛ برای همین به
نام مسیر مطلق شناخته میشود. برای پیدا کردن مسیر مطلق یک فایل ، میتوان از
os.path.abspath استفاده کرد :

&gt;&gt;&gt; os.path.abspath('memo.txt')

'/home/dinsdale/memo.txt'

os.path توابع دیگری را برای کار با نام و مسیر فایل ها فراهم میکند. برای
مثال ، os.path.exists چک میکند که فایل یا دایرکتوری فعلی وجود دارد یا
خیر :

&gt;&gt;&gt; os.path.exists('memo.txt')

True

اگر وجود داشته باشد ، os.path.isdir چک میکند که آیا این مسیر دایرکتوری
هست یا خیر :

&gt;&gt;&gt; os.path.isdir('memo.txt')

False

&gt;&gt;&gt; os.path.isdir('/home/dinsdale')

True

به همین شکل ، os.path.isfile چک میکند که آیا این مسیر یک فایل هست یا
خیر.

os.listdir یک لیست از فایل ها (و دایکتوری های دیگر) را در دایکتوری فعلی
برمیگرداند:

&gt;&gt;&gt; os.listdir(cwd)

\['music', 'photos', 'memo.txt'\]

برای نشان دادن این توابع ، مثال بعدی در داخل یک دایرکتوری پیمایش میکند،
و اسم تمام فایل ها را چاپ کرده ، و به صورت بازگشتی خود را برای تمام
دایرکتوری ها صدا میکند :

def walk(dirname):

 for name in os.listdir(dirname):

 path = os.path.join(dirname, name)

 if os.path.isfile(path):

 print(path)

 else:

 walk(path)

os.path.join دایرکتوری و نام فایل را میگیرد و آن ها را متصل میکند تا
مسیر کامل بدست آید.

ماژول os تابعی با نام walk فراهم میکند که شبیه همین تابع هست اما جامع تر
است. به عنوان یک تمرین، مستندات را بخوانید و از آن برای چاپ نام فایل های
درون یک دایرکتوری و زیردایرکتوری های آن استفاده کنید. شما میتوانید راه
حل من را از http://thinkpython2.com/code/walk.py دانلود نمایید.

۱۴.۵ گرفتن اکسپشن ها

در موقع خواندن یا نوشتن در فایل ، خیلی چیز ها ممکن است با مشکل مواجه
شوند. اگر شما سعی کنید فایلی را باز کنید که وجود ندارد، شما یک خطای
IOError دریافت میکنید:

&gt;&gt;&gt; fin = open('bad\_file')

IOError: \[Errno 2\] No such file or directory: 'bad\_file'

اگر شما اجازه دسترسی به یک فایل را نداشته باشید :

&gt;&gt;&gt; fout = open('/etc/passwd', 'w')

PermissionError: \[Errno 13\] Permission denied: '/etc/passwd'

و اگر سعی کنید یک دایرکتوری را برای خواندن باز کنید :

&gt;&gt;&gt; fin = open('/home')

IsADirectoryError: \[Errno 21\] Is a directory: '/home'

برای اجتناب از این خطاها ، شما میتوانید از توابعی مانند os.path.exists و
os.path.isfile استفاده کنید، اما چک کردن تمام احتمالات ممکن است زمان
زیادی طول بکشد. (اگر “Errno 21” نمایش داده شود ، یعنی حداقل ۲۱ اشتباه
ممکن است رخ داده باشد )

بهتر است که جلو بروید و تلاش کنید - و اگر مشکلی رخ داد با آن مقابله کنید
- دقیقا کاری را میکنید که دستور try انجام میدهد. سینتکس آن بسیار شبیه
دستور if….else میباشد:

try:

 fin = open('bad\_file')

except:

 print('Something went wrong.')

پایتون اول سعی میکند تا بند try را اجرا کند. اگر همه چیز خوب پیش برود ،
از بند except پرش میکند و ادامه میدهد. اگر اکسپشنی رخ داد ، از بند try
خارج میشود و بند except را اجرا میکند.

مدیریت اکسپشن با یک دستور try به نام گرفتن اکسپشن شناخته میشود. در این
مثال ، بند except فقط یک پیغام خطا چاپ میکند که خیلی سودمند نیست. در
حالت کلی ، گرفتن یک اکسپشن به شما فرصتی میدهد تا بتواند مشکل به وجود
آمده را برطرف کنید ، دوباره سعی کنید و یا حداقل برنامه را به طور عادی
اتمام برسانید.

۱۴.۶ پایگاه های داده

یک پایگاه داده ، فایلی است که برای ذخیره سازی داده ها به وجود آمده
است.بسیاری از پایگاه های داده مانند یک دیکشنری ساخته می شوند چون مانند
دیکشنری ها با گرفتن یک کلید ، یک مقدار به ما تحویل می دهند. بزرگ ترین
تفاوت بین یک پایگاه داده و یک دیکشنری این است که دیتابیس روی دیسک (یا
حافظه های دائمی دیگر) ذخیره می شود و به همین دلیل پس از اتمام کار برنامه
اطلاعات حفظ می شوند.

ماژول dbm یک رابط برای ساختن و به روزرسانی فایل ها پایگاه داده است. به
عنوان مثال یک پایگاه داده خواهیم ساخت که برای عکس ها یک عنوان ذخیره کند.

&gt;&gt;&gt; import dbm

&gt;&gt;&gt; dbm = dbm.open (‘captions’ , ‘c’)

حالت c به این معنی است که اگر پایگاه داده تا به اینجا ساخته نشده است و
وجود ندارد ،‌باید ساخته شود.حاصل یک شی پایگاه داده که میتواند برای اکثر
عملیات ها مانند یک دیکشنری استفاده شود.

هنگامی که یک آیتم جدید می سازید ، dbm فایل پایگاه داده را به روزرسانی می
کند.

&gt;&gt;&gt; db \[‘cleese.png’\] = ‘ Photo of John Cleese . ‘

هنگامی که به یکی از آن ایتم ها دسترسی پیدا میکنید ، dbm فایل را می
خواند:

&gt;&gt;&gt; db \[ ‘cleese.png’\]

b’Photo of John Cleese.’

حاصل یک شیء بایت(bytes object) است که به همین خاطر با b شروع شده.شیء
بایت از خیلی جهات شبیه به رشته ها(String)است.وقتی بیشتر پیش می روید
اهمیت این تفاوت رو بهتر متوجه می شوید اما درحال حاضر میتوانیم این تفاوت
را نادیده بگیریم.

اگر شما مقدار دیگری را به کلید فعلی بدهیدdbm مقدار قدیمی آن کلید
رابامقدار جدیدی که دادید عوض میکند.

&gt;&gt;&gt; db\[‘clesse.png’\] = ‘Photo of John Clesse doing a silly
walk.’

&gt;&gt;&gt; db\[‘clesse.png’\]

b ‘Photo of John Clesse doing a silly walk.’

بعضی از متدها مثل keys و items برای اشیاء پایگاه داده ای‌ (database
objects) کار نمیکنند اما ایجاد تکرار با حلقه for برای این اشیاء کار
میکند:

For key in db:

 print (key, db\[key\])

مثل کار با فایل ها بعد از پایان کارباید پایگاه داده را ببندید:

&gt;&gt;&gt; db.close()

 ۱۴.۷ ذخیره سازی موقت با استفاده از pickling

محدودیت dbm این است که کلید و مقدار (key and value) حتما باید از جنس
رشته (string) یا bytes باشند اگر بخواهید از انواع دیگری استفاده کنید به
error برخورد می کنید.

ماژول pickle می تواند در این مورد به ما کمک کند.این ماژول تقریبا هر نوع
object ای را به رشته مناسب برای ذخیره سازی در پایگاه داده ترجمه میکند و
سپس میتواند آن رشته را به object ای که از آن ساخته شده بر میگرداند.

عبارت pickle.dumps یک شیء را به عنوان پارامتر میگیرد و یک رشته برمی
گرداند (dumps مخفف عبارت "dump string" است).

&gt;&gt;&gt; import pickle

&gt;&gt;&gt; t = \[1, 2, 3\]

&gt;&gt;&gt; pickle.dumps(t)

b’\\x80\\x03\]q\\x00(k\\x01k\\x02k\\x03e.’

این فرمت برای انسان قابل خواندن نیست درحالیکه pickle به راحتی آن را
ترجمه میکند. عبارت pickle.loads("load string") شیء اولیه را دوباره
میسازد:

&gt;&gt;&gt; t1 = \[1, 2, 3\]

&gt;&gt;&gt; s = pickle.dumps(t1)

&gt;&gt;&gt; t2 = pickle.loads(s)

&gt;&gt;&gt; t2

\[1, 2, 3\]

اگرچه شیء جدید همان مقدارهای شیء قدیمی را دارد اما (به طور کلی) همان شیء
نیست:

&gt;&gt;&gt; t1 == t2

True

&gt;&gt;&gt; t1 is t2

False

به عبارت دیگرpickle کردن و unpickle کردن همان تاثیری را دارد که کپی کردن
یک شیء دارد.

شما میتوانید از pickle برای ذخیره سازی چیزهایی که از جنس
رشته(string)نیستند استفاده کنید.درواق این اتفاق زیاد می افتد که در
ماژولی به اسم shelve گنجانده شده است

تمرین ۱۴.۳ اگر راه حل من برای تمرین ۱۲.۴ را از سایت
[*http*](http://thinkpython.com/code/anagram_sets.py)[*://*](http://thinkpython.com/code/anagram_sets.py)[*thinkpython*](http://thinkpython.com/code/anagram_sets.py)[*.*](http://thinkpython.com/code/anagram_sets.py)[*com*](http://thinkpython.com/code/anagram_sets.py)[*/*](http://thinkpython.com/code/anagram_sets.py)[*code*](http://thinkpython.com/code/anagram_sets.py)[*/*](http://thinkpython.com/code/anagram_sets.py)[*anagram*](http://thinkpython.com/code/anagram_sets.py)[*\_*](http://thinkpython.com/code/anagram_sets.py)[*sets*](http://thinkpython.com/code/anagram_sets.py)[*.*](http://thinkpython.com/code/anagram_sets.py)[*py*](http://thinkpython.com/code/anagram_sets.py)
دانلود کنید خواهید دید که این کد یک دیکشنری درست میکند که نگاشتی است از
حروف مرتب شده به لیستی از کلماتی که میتوانند با آن حروف تلفظ شوند مثلا
کلمه 'opst' به این لیست نگاشت می شود: \['opts', 'post', 'pots', 'spot',
'stop', 'tops'\].

یک ماژول بنویسید که anagram\_setes را import کند و دوتا تابع جدید فراهم
نماید: store\_anagrams که باید دیکشنری را در یک shelf ذخیره کند و دیگری
read\_anagrams که باید به دنبال یک کلمه بگردد و لیست آناگرام های آن را
برگرداند. راه حل:
[*http*](http://thinkpython.com/code/anagram_db.py)[*://*](http://thinkpython.com/code/anagram_db.py)[*thinkpython*](http://thinkpython.com/code/anagram_db.py)[*.*](http://thinkpython.com/code/anagram_db.py)[*com*](http://thinkpython.com/code/anagram_db.py)[*/*](http://thinkpython.com/code/anagram_db.py)[*code*](http://thinkpython.com/code/anagram_db.py)[*/*](http://thinkpython.com/code/anagram_db.py)[*anagram*](http://thinkpython.com/code/anagram_db.py)[*\_*](http://thinkpython.com/code/anagram_db.py)[*db*](http://thinkpython.com/code/anagram_db.py)[*.*](http://thinkpython.com/code/anagram_db.py)[*py*](http://thinkpython.com/code/anagram_db.py)

۱۴.۸ لوله ها

بیشتر سیستم عامل ها محیط command line را فراهم میکنند که به آن shell هم
گفته میشود. Shell ها معمولا دستوراتی را فراهم میکنند که میتوان در فایل
سیستم جستجو کرد و برنامه ها را اجرا کرد. به عنوان مثال در unix شما
میتوانید با دستور cd مسیر دایرکتوری فعلی را عوض کنید یا با دستور ls
محتوای دایرکتوری فعلی را مشاهده کنید و یا یک مرورگر وب را باز کنید (مثلا
دستور firefox).

هر برنامه ای که شما آن را از طریق shell اجرا کنید می توانید از python هم
آن را با استفاده از لوله (pipe)باز کنید.

به عنوان مثال دستور ls -l در unix محتوای دایرکتوری جاری را نمایش می
دهد(با فرمت طولانی) شما میتوانید دستور ls را با os.popen اجرا کنید:

&gt;&gt;&gt; cmd = ‘ls -l’

&gt;&gt;&gt; fp = os.popen(cmd)

در واقع آرگومان cmd یک رشتهاست که حاوی دستور shell می باشد. مقدار برگشتی
یک شیء است که مانند یک فایل باز رفتار میکند. شما می توانید خروجی را از
پردازه ls بصورت یک خط یک خط با استفاده از readline و یا بصورت کلی با
دستور read بخوانید:

&gt;&gt;&gt; res = fp.read()

وقتی کار شما مانند استفاده از یک فایل باید لوله را ببندید:

&gt;&gt;&gt; stat = fp.close()

&gt;&gt;&gt; print stat

None

مقدار برگشتی وضعیت نهایی پردازه ls است. None به این معنی است که به صورت
عادی (و بدون هیچ خطایی) پردازه پایان یافته است.

به طور مثال اکثر سیستم های برپایهUnix دستوری به اسم md5sum را فراهم
میکنند که محتوای یک فایل را میخواند و یک checksum را محاسبه میکند. شما
میتوانید درباره MD5 در سایت
[*http*](http://en.wikipedia.org/wiki/Md5)[*://*](http://en.wikipedia.org/wiki/Md5)[*en*](http://en.wikipedia.org/wiki/Md5)[*.*](http://en.wikipedia.org/wiki/Md5)[*wikipedia*](http://en.wikipedia.org/wiki/Md5)[*.*](http://en.wikipedia.org/wiki/Md5)[*org*](http://en.wikipedia.org/wiki/Md5)[*/*](http://en.wikipedia.org/wiki/Md5)[*wiki*](http://en.wikipedia.org/wiki/Md5)[*/*](http://en.wikipedia.org/wiki/Md5)[*Md*](http://en.wikipedia.org/wiki/Md5)[*5*](http://en.wikipedia.org/wiki/Md5)
مطالعه کنید. این دستور یک راه موثر برای چک کردن اینکه آیا دو فایل دارای
محتوای یکسانی هستند ارایه میکند.احتمال اینکه محتواهای متفاوت دارای
checksum های یکسانی باشند خیلی کم است (این اتفاق احتمالا تا قبل از اینکه
جهان از هم نپاشد رخ نمیدهد)

شما میتوانید از یک لوله برای اجرای md5sum در پایتون استفاده کنید و نتیحه
را بدست بیاورید:

&gt;&gt;&gt; filename = ‘book.tex’

&gt;&gt;&gt; cmd = ‘md5sum’ + filename

&gt;&gt;&gt; fp = os.popen(cmd)

&gt;&gt;&gt; res = fp.read()

&gt;&gt;&gt; stat = fp.close()

&gt;&gt;&gt; print res

1e0033f0ed0656636de0d75144ba32e0

&gt;&gt;&gt; print stat

None

تمرین ۱۴.۴ در یک مجموعه بزرگ از فایل های mp3 ممکن است بیش از یک کپی از
یک آهنگ در دایرکتوری های دیگر یا در همین دایرکتوری(و با نامی دیگر) ذخیره
شده باش. هدف این تمرین جستجو برای یافتن آهنگ های تکراری است.

۱.برنامه ای بنویسید که در دایرکتوری فعلی و تمام
زیردایرکتوری(subdirectory)های آن به صورت بازگشتی جستجو کند و لیست آدرس
تمامی فایل هایی که با پسوند داده شده هستند (مثلا mp3)را برگرداند.
راهنمایی: os.path چندین تابع مفید برای دستکاری فایل ها و اسم آدرسشان را
فراهم میکند

۲.برای تشخیص آهنگ های تکراری شما میتوانید از md5sum برای محاسبه checksum
برای هر فایل استفاده کنید. اگر دو فایلchecksum یکسان داشتند آنها احتمالا
محتوای یکسانی هم دارند

۳.برای محکم کاری شما میتوانید از دستور diff که در Unix است هم استفاده
کنید

راه حل: http://thinkpython.com/code/find\_duplicates.py

۱۴.۹ نوشتن ماژول ها

هر فایلی که شامل کد پایتون باشد را میتوان به عنوان ماژول وارد برنامه
کرد. به طور مثال، فرض کنید فایلی با اسم wc.py شامل کد زیر داریم:

def linecount(filename):\
 count = 0\
 for line in open(filename):\
 count += 1\
 return count\
\
print linecount('wc.py')\
\

اگر این برنامه را اجرا کنید کد خودش را میخواند و تعداد خط های آن را چاپ
میکند. همینطور میتواند آن را به این شکل وارد کنید:

&gt;&gt;&gt; import wc\
7\
\

حالا ما یک ماژول به اسم wc داریم:

&gt;&gt;&gt; print wc\
&lt;module 'wc' from 'wc.py'&gt;\
\

اینکار تابع linecount را در اختیار ما قرار میدهد:

&gt;&gt;&gt; wc.linecount('wc.py')\
7

به این شکل یک ماژول در پایتون مینویسیم.

تنها مشکل وارد کردن یک ماژول در پایتون این است که کد تست انتهایی را اجرا
میکند. معمولا وقتی یک ماژول را وارد میکنید توابع جدیدی ایجاد میکند ولی
آنها را اجرا نمیکند.

برنامه هایی که به عنوان ماژول وارد میشود از قطعه زیر استفاده میکنند:

if \_\_name\_\_ == '\_\_main\_\_':\
 print linecount('wc.py')

متغیر توکار \_\_name\_\_ وقتی برنامه اجرا میشود مقدار دهی میشود. اگر
برنامه به شکل اسکریپت اجرا شود \_\_name\_\_ دارای مقدار \_\_main\_\_
است؛ یعنی وقتی کد اجرا میشود. در غیر اینصورت، وقتی ماژول وارد میشود کد
تست اجرا نمیشود.

تمرین ۵

این تمرین را در فایلی به اسم wc.py بنویسید و آن را به عنوان اسکریپت اجرا
کنید. سپس مفسر پایتون را اجرا کنید و wc را import کنید. مقدار
\_\_name\_\_ وقتی به عنوان ماژول اجرا شود چیست؟

هشدار: اگر ماژولی که یک بار import کرده اید را دوباره import کنید،
پایتون هیچ کاری نمیکند. حتی اگر فایل تغییری کرده باشد، دوباره آن را
نمیخواند.

اگر میخواهید یک ماژول را دوباره باز کنید، میتواند از تابع از پیش ساخته
reload استفاده کنید، ولی کمی پیچیده است. در نتیجه بهترین را این است که
مفسر را دوباره اجرا کنید و ماژول را دوباره import کنید.

14.10 رفع ایراد

وقتی میخواهید فایل ها را بخوانید یا بنویسید، ممکن به مشکلاتی با قسمت های
خالی بخورید (Whitespace) این خطا ها ممکن است مشکل ایجاد کند چون فاصله
ها، تب ها و خط های جدید معمولا نامرئی هستند.

&gt;&gt;&gt; s = ‘1 2\\t 3\\n 4’

&gt;&gt;&gt; print s

1 2 3

3

تابع از پیش ساخته repr میتواند اینجا کمک کند. این تابع هر شی ای را به
عنوان ورودی میگیرد و رشته متناظر با آن را برمیگرداند. برای رشته ها، در
رشته متناظر خروجی کاراکتر های خالی با Backslash مشخص میکند.

&gt;&gt;&gt; print repr(s)

‘1 2\\t 3\\n 4’

این میتواند برای رفع ایراد کمک کند.

مشکل دیگر که ممکن است به آن بخورید این است که سیستم های مختلف از کاراکتر
های مختلف برای نمایش پایان خط استفاده میکنند. برخی از newline استفاده
میکنند که با \\n نمایش داده میشد و برخی از کاراکتر return که با \\r
نمایش داده میشود. برخی از سیستم ها از هر دوی آنها استفاده میکنند. اگر
فایل ها را بین سیستم های مختلف جابجا کنید ممکن با این ناهماهنگی به مشکل
بخورید.

برای برخی سیستم ها برنامه هایی وجود دارد که میتوانند هر کدام از این فرمت
ها را به دیگری تبدیل کنند. میتوانید آنها را در اینجا پیدا کنید و بیشتر
در مورد آنها بدانید.[
](http://en.wikipedia.org/wiki/Newline)[*http*](http://en.wikipedia.org/wiki/Newline)[*://*](http://en.wikipedia.org/wiki/Newline)[*en*](http://en.wikipedia.org/wiki/Newline)[*.*](http://en.wikipedia.org/wiki/Newline)[*wikipedia*](http://en.wikipedia.org/wiki/Newline)[*.*](http://en.wikipedia.org/wiki/Newline)[*org*](http://en.wikipedia.org/wiki/Newline)[*/*](http://en.wikipedia.org/wiki/Newline)[*wiki*](http://en.wikipedia.org/wiki/Newline)[*/*](http://en.wikipedia.org/wiki/Newline)[*Newline*](http://en.wikipedia.org/wiki/Newline)
و البته خودتان هم میتواند یکی از این برنامه ها را بنویسید.

14.11 دایره لغات

persistent (پایا):

برنامه ای که به طور محدودی اجرا میشود و برخی از داده را در حافظه دائمی
نگهداری میکند.

format operator (عملگر فرمت):

یک عملگر، %، که یک رشته فرمت و یک tuple میگیرد و رشته را به همراه المان
های tuple فرمت میکند و برمیگرداند.

format string (رشته فرمت):

یک رشته که با عملگر های فرمت، رشته های فرمت در آن مشخص شده است.

format sequence (دنباله فرمت):

یک دنباله از کاراکتر ها در یک رشته فرمت، مثل %d، که نشان میدهد مقدار
چطور باید فرمت شود.

text file (فایل متنی):

دنباله ای از کاراکتر ها که در حافظه دائمی مثل هارد درایو ذخیره شده اند.

directory:

مجموعه ای نامدار از فایل ها، همینطور به آن پوشه میگویند.

path (آدرس):

رشته ای که یک فایل را مشخص میکند.

relative path (آدرس نسبی):

آدرسی که از جای فعلی شروع میشود.

absolute path (آدرس دقیق):

آدرسی که از بالاترین پوشه در فایل سیستم شروع میشود.

catch (گرفتن):

برای جلوگیری از اینکه یک استثناء برنامه را ببندد که با try و expect
نوشته میشود.

database (پایگاه داده):

یک فایل که محتوای آن مانند دایره لغات با کلید و مقدار متناظر نوشته شده
است.

14.12 تمرین ها

تمرین 6

ماژول urllib شامل متدهایی برای دستکار URL و دریافت اطلاعات از وب است. کد
زیر یک پیام مخفی از سایت thinkpython.com دانلود و نمایش میدهد.

import urllib

conn =
urllib.urlopen(‘[*http*](http://thinkpython.com/secret.html)[*://*](http://thinkpython.com/secret.html)[*thinkpython*](http://thinkpython.com/secret.html)[*.*](http://thinkpython.com/secret.html)[*com*](http://thinkpython.com/secret.html)[*/*](http://thinkpython.com/secret.html)[*secret*](http://thinkpython.com/secret.html)[*.*](http://thinkpython.com/secret.html)[*html*](http://thinkpython.com/secret.html)’)

for line in conn:

print line.strip()

این کد را اجرا کنید و روند گفته شده را اجرا کنید. راه حل:[
](http://thinkpython.com/code/zip_code.py)[*http*](http://thinkpython.com/code/zip_code.py)[*://*](http://thinkpython.com/code/zip_code.py)[*thinkpython*](http://thinkpython.com/code/zip_code.py)[*.*](http://thinkpython.com/code/zip_code.py)[*com*](http://thinkpython.com/code/zip_code.py)[*/*](http://thinkpython.com/code/zip_code.py)[*code*](http://thinkpython.com/code/zip_code.py)[*/*](http://thinkpython.com/code/zip_code.py)[*zip*](http://thinkpython.com/code/zip_code.py)[*\_*](http://thinkpython.com/code/zip_code.py)[*code*](http://thinkpython.com/code/zip_code.py)[*.*](http://thinkpython.com/code/zip_code.py)[*py*](http://thinkpython.com/code/zip_code.py)


