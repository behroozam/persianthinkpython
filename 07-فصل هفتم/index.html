<!--
	This Basic theme serves as an example for how to create other
	themes by demonstrating the features with minimal HTML and CSS.
	Comments like this will be through the code to explain briefly
	what each feature is and point you to the MkDocs documentation
	to find out more.
-->
<!DOCTYPE html>
<head>
	
	<meta charset="UTF-8" />
	
	<!--
		The page_title contains the title for a page as shown in the navigation.
		Site name contains the name as defined in the mkdocs.yml
	-->
	<title>07 فصل هفتم - تفکر پایتونی</title>

	<!--
		Support custom favicon support.
		http://www.mkdocs.org/user-guide/configuration/#site_favicon
	-->
	
		<link rel="shortcut icon" href="../img/favicon.ico">
	

	<!--
		You can include external assets of course, but be aware that it means the
		documentation may not work well offline.
	-->
	<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">

	<link rel="stylesheet" href="../css/theme.css">

	<!--
		extra_ess contains paths to CSS files in the users
		documentation directory or a list of CSS files defined in
		their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_css
	-->
	

	<link rel="stylesheet" href="../css/darkula.css">
	<script src="../js/highlight.pack.js"></script>
	
	<!--
		Include Google Analytics tracking code.

		http://www.mkdocs.org/user-guide/configuration/#google_analytics
	-->
	

	
	
</head>

<body>

	<div class="sidebar left">

		<ul>
		
			
				
				

	<li >
	
		<a href="..">Home</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../01-فصل اول/">01 فصل اول</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../02-فصل دوم/">02 فصل دوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../03-فصل سوم/">03 فصل سوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../04-فصل چهارم/">04 فصل چهارم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../05-فصل پنجم/">05 فصل پنجم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../06-فصل ششم/">06 فصل ششم</a>
		
	</li>


			
			
				
				

	<li class="active">
	
		<a href="./">07 فصل هفتم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../08-فصل هشتم/">08 فصل هشتم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../09-فصل نهم/">09 فصل نهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../10-فصل دهم/">10 فصل دهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../11-فصل یازدهم/">11 فصل یازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../12-فصل دوازدهم/">12 فصل دوازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../13-فصل سیزدهم/">13 فصل سیزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../14-فصل چهاردهم/">14 فصل چهاردهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../15-فصل پانزدهم/">15 فصل پانزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../16-فصل شانزده/">16 فصل شانزده</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../17-فصل هفده /">17 فصل هفده </a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../18-فصل هجده/">18 فصل هجده</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../19-فصل نوزده/">19 فصل نوزده</a>
		
	</li>


			
			
		
		</ul>
		
	</div>
	
	<div class="body rel right">
	
		<header>
		
			<div class="right">
			
				<h1>07 فصل هفتم - تفکر پایتونی</h1>
			
			</div>
		
			<div role="search" class="left">
			
				<form action="../search.html" class="rel" method="get">
				
					<input type="text" name="q" placeholder="جستجو" />
					
					<input type="submit" class="abs search-submit" value="" />
					
				</form>
				
			</div>
		
		</header>
		
		<main class="rel oh">
		
			
		
				<div class="left toc">
				
					<ul>
						
						
						
					</ul>
					
				</div>
			
			
			
			<div class="right content">
		
				
					
					<p>فصل ۷</p>
<p>پیمایش</p>
<p>این فصل در مورد پیمایش است که به معنی توانایی اجرای مکرر یک بلاک از
دستورات است. نوعی از پیمایش را در بخش ۵.۸ هنگام استفاده از توابع بازگشتی
دیدیم. همچنین نوع دیگری را در بخش ۴.۲ هنگام استفاده از حلقه for دیدیم.
در این بخش می‌خواهیم نوعی دیگر از پیمایش را ، با استفاده از گزاره while
ببینیم. اما اول می‌خواهم مقداری در مورد تخصیص متغیر صحبت کنم.</p>
<p>۷.۱ باز تخصیص</p>
<p>همان‌طور که ممکن است متوجه شده باشید،‌ این قانونی است که بیشتر از یک
تخصیص به متغیر مشابه داشته باشیم. تخصیص جدید مقدار جدیدی را به متغیر
موجود ارجاع می دهد. ( و ارجاع مقدار قدیمی را متوقف می کند.)</p>
<p>&gt;&gt;&gt; x = 5</p>
<p>&gt;&gt;&gt; x</p>
<p>5</p>
<p>&gt;&gt;&gt; x = 7</p>
<p>&gt;&gt;&gt; x</p>
<p>7</p>
<p>اولین باری که ما مقدار x را نمایش دادیم مقدارش ۵ بود؛ و دومین بار مقدار
آن ۷ است.</p>
<p>شکل ۷.۱ از طریق دیاگرام وضعیت، چگونگی باز‌تخصیص را نشان می دهد.</p>
<p>در این جا می‌خواهم به یک یک اشتباه رایج اشاره کنم . به دلیل اینکه پایتون
از یک نشان برابری (=) برای تخصیص استفاده می کند، وسوسه انگیز است که که
عبارتی مثل a = b را با معنای ریاضیاتی «برابری» تفسیر کنیم ؛ این ادعا به
این معناست که a و b برابند. اما این تفسیر نادرست است.</p>
<p>ابتدا، برابری یک مفهوم دو‌طرفه است اما تخصیص نیست. برای مثال، در
ریاضیات، اگر a =۷ باشد بنابر این a = ۷ است. اما در پایتون جمله a= ۷
قانونی است و ۷=a نیست.</p>
<p>همچنین در ریاضیات ،یک گزاره برابری درست یا نا درست برای تمام دوران است.
حال اگر a=b باشد بنابراین a همیشه برابر b خواهد بود. در پایتون ، یک جمله
تخصیص می‌تواند دو متغیر را برابر سازد اما اینگونه نمی‌تواند :</p>
<hr />
<hr />
<p>&gt;&gt;&gt; a = 5</p>
<p>&gt;&gt;&gt; b = a</p>
<p>&gt;&gt;&gt; a = 3</p>
<p>&gt;&gt;&gt; b</p>
<p>5</p>
<p>خط سوم مقدار متغیر a را تغییر می‌دهد اما مقدار متغیر b را تغییر نمی
دهد،‌بنابراین آن‌ها دیگر برابر نیستند.</p>
<p>بازتخصیص متغیر اکثراً مفید است،‌اما باید با احتیاط از آن استفاده کنید.
اگر مقدار یک متغیر مکرراً تغییر کند،‌ می‌تواند خواندن و اشکال‌زدایی کد
را سخت کند.</p>
<p>۷.۲ بروزرسانی متغیر</p>
<p>نوع پرکاربردی از باز‌تخصیص بزوررسانی است، که در آن مقدار جدید متغیر
وابسته است به مقدار قدیمی آن.</p>
<p>&gt;&gt;&gt; x= x + 1</p>
<p>این یعنی « مقدار متغیر x را بگیر،‌یک واحد به آن اضافه کن، سپس مقدار x را
با مقدار جدید بروزآور رسانی کن‌»</p>
<p>اگر شما تلاش کنید تا متغیری را بروز رسانی کنید که وجود ندارد، شما خطایی
در یافت خواهید کرد، به این خاطر که پایتون سمت راست محاسبه می‌کند قبل از
آنکه به x مقداری تخصیص دهد.</p>
<p>&gt;&gt;&gt; x = x + 1</p>
<p>NameError: name 'x' is not defined</p>
<p>قبل از اینکه متغیر را بروز رسانی کنید شما باید آن را مقداردهی اولیه
کنید، اینکار معمولاً با یک تخصیص ساده اتفاق می افتد:</p>
<p>&gt;&gt;&gt; x = 0</p>
<p>&gt;&gt;&gt; x = x + 1</p>
<p>بروزرسانی یک متغیر با اضافه کردن یک واحد را افزایش؛‌ و کم نمودن یک واحد
را کاهش می گویند.</p>
<p>۷.۳ دستور while</p>
<p>کامپیوتر ها معمولاً برای انجام وظایف پرتکرار خودکار استفاده می شوند.
تکرار کردن وضایف هماند یا وظایف مشابه بدون ایجاد اشکال و اشتباه چیزی است
که کامپیوتر ها عالی انجام می‌دهند و افراد در آن ضعیف هستند. در یک برنامه
کامپیوتری، تکرار<a href="../repetition">^1</a> را پیمایش<a href="../iteration.">^2</a> هم می نامند.</p>
<p>همچنین ما دو تابع شمارش معکوس و چاپ n مرتبه را دیده ایم. در این روش
تکرار از بازگشتی استفاده شده بود. به دلیل اینکه پیمایش بسیار معمول
است،‌پایتون ویژگی‌های زبانی را مهیا ساخته تا آن را آسان‌تر کند.یکی از
آن‌ها دستور for است که در بخش ۴.۲ دیدیم. بعداً به آن باز خواهیم گشت.</p>
<p>یکی دیگر از آن های دستور while است. در اینجا نسخه از شمارش معکوس آورده
شده است که در آن از دستور while استفاده شده است.</p>
<p>Def countdown (n):</p>
<p>while n &gt; 0:</p>
<p>print (n)</p>
<p>n = n-1</p>
<p>print ('Blastoff')</p>
<p>شما می‌توانید دستور while را همانگونه که انگلیسی را می‌خوانید،‌بخوانید.
این بدین معناست که «هنگامی که n از صفر بزرگ‌تر است، مقدار n را نمایش بده
سپس یک واحد از آن کم کن. زمانی که به صفر رسیدی ، عبارت Blastoff را نمایش
بده. »</p>
<p>به طور عمومی، روند اجرای دستور while اینگونه است:</p>
<p>۱- ارزیابی اینکه شرط درست یا نادرست است.</p>
<p>۲- اگر برقرار نیست از گزاره while خارج شود و بقیه دستورات را اجرا نماید.</p>
<p>۳- اگر شرط صحیح است،‌ دستورات را اجرا کند و به مرحله اول برود.</p>
<p>این مدل از دستورات حلقه<a href="../loop">^3</a> خوانده می‌شود چرا که مرحله سوم حلقه آن را به
ابتدای آن بر می گرداند.</p>
<p>بدنه حلقه باید مقدار یک یا چند متغیر را تغییر دهد تا در نهایت شرط مقدار
ناصحیح پیدا کند و حلقه بسته شود. در غیر اینصورت حقله برای همیشه تکرار
خواهد شد، که به آن حلقه بی نهایت[^4] گفته می شود. منبع نامحدود از سرگرمی
برای دانشمندان کامپیوتر دستور العمل های روی شامپو است</p>
<p>"شامپو را روی سر بمالید , با آب شستشو دهید , دوباره تکرار کنید" در حقیقت
یک حلقه ی بینهایت است.</p>
<p>در مثاال شمارنده معکوس، می‌توانیم بسته شدن حلقه را اثبات کنیم : اگر n
صفر یا منفی شود، حلقه هرگز اجرا نخواهد شد. در غیر اینصورت، هر بار مقدار
n درون حلقه کمتر می‌شود تا در نهایت صفر شود.</p>
<p>برای برخی از حلقه ها بیان آن آان نیست. برای مثال :</p>
<p>def sequence (n):</p>
<p>while n != 1:</p>
<p>print(n)</p>
<p>if n%2 == 0:# n is even</p>
<p>n = n /2</p>
<p>else:# n is odd</p>
<p>n = n*3+1</p>
<p>شرظ برای این حلقه این است که n !=1، پس حلقه ادامه خواد یافت تا زمانی که
n برابر ۱ شود، که شرط آن ناصحیح شود.</p>
<p>هر بار در وسط حلقه ، برنامه مقدار n را خروجی می‌دهد سپس بررسی می‌کند که
زوج یا فرد است. اگر زوج باشد بر ۲ تقسیم می شود. اگر فرد باشد، مقدار n با
n*3+1 جایگزین می شود. برای مثال،‌اگر ورودی دنباله ۳ باشد، نتیجه مقدار n
به ترتیب برابر ۳،۱۰،۵،۱۶،۸،۴،۲،۱ می شود.</p>
<p>به دلیل اینکه مقدار n گاهی زیاد و گاهی کم می شود، اثبات روشنی برای اینکه
چه زمانی ۱ خواهد شد ، یا برنامه بسته می‌شود وجود ندارد. برای برخی مقدار
های خاص n ، می‌توانیم پایان پذیری را اثبات کنیم. برای مثال،‌ اگر مقدار
شروع کننده یکی از مضارب ۲ باشد، مقدار n هر بار در حلقه زوج خواهد بود تا
زمانی که برابر ۱ شود. مثال قبلی با چنین دنباله ای پایان می‌یابد اگر با
۱۶ شروع شود.</p>
<p>سؤال سخت این است که آیا می‌توانیم اثبات کنیم که این برانامه برای همه
مقادیر مثبت n پایان پذیر است. زمان زیادی است که هیچ‌کس نتواسنته /آن را
اثبات یا رد کند! ( ببینید
<a href="http://en.wikipedia.org/wiki/Collatz_conjecture">http://en.wikipedia.org/wiki/Collatz_conjecture</a>)</p>
<p>برای تمرین ، تابع print_n از بخش 5.8 با تکرار بجای بازگشتی بازنویسی
کنید.</p>
<p>۷.۴ break</p>
<p>بعضی اوقات تا زمانی که نیمه حلقه نرسیدید نمی‌دانید زمان آن است که حلقه
پایان بپذیرد. در این مواقع شما می‌توانید برای خارج شدن از حلقه از دستور
break استفاده کنید.</p>
<p>برای مثال، فرض کنید، می خواهیداز کاربر تاز مانی که عبارت done را بنویسند
مقدار بگیرید. شما می‌توانید بنویسید:</p>
<p>while True:</p>
<p>line = input( '&gt; ')</p>
<p>if line == 'done' :</p>
<p>break</p>
<p>print (line )</p>
<p>print('Done')</p>
<p>شرط حلقه صحیح است که یعنی برای همیشه صحیح است، پس حلقه اجرا می‌شود تا
زمانی که به گزاره break برخورد کند.</p>
<p>هر زمان که اجرا می شود،‌ کاربر را با علامت براکت شکسته &lt; مواجه
می‌سازد. اگر کاربر تایپ کند done، گزاره break ، برنامه را از حلقه خارج
می سازد.در غیر این صورت برنامه هر چه را که کاربر تایپ نماید بازتاب
می‌دهد و به ابتدای حلقه باز می گردد. اجرای ساده آن اینچنین است:</p>
<p>&gt; not done</p>
<p>not done</p>
<p>&gt; done</p>
<p>Done!</p>
<p>این راه برای نوشتن حلقه های while معمول است زیرا شما می توایند در هر
کجای حلقه ( نه فقط در ابتدا ) شرط را بررسی کنید و شما می‌توانید شرط
پایانی را مثبت بیان کنید (“زمانی که اتفاق افتاد، متوقف شو ”) نسبت به
بیان منفی (“ادامه بده تا زمانی که اتفاق بی افتد. ”)</p>
<p>۷.۵ ریشه‌های دوم</p>
<p>حلقه ها معمولاً در برنامه‌هایی استفاده می‌شوند که نتایج عددی را با نزدیک
کردن جواب و تکرار آن محاسبه می‌کنند و بهبود می بخشند.</p>
<p>برای مثال، یکی از راه‌های محاسبه ریشه دوم روش نیوتون است. فرض می‌کنیم که
شما می‌خواهید تا ریشه دوم a را بدانید. با تقریباً هر تخمینی از (x) که
شروع کنید با استفاده از فرمول زیر در هر مرحله به عدد بهتری می‌رسید.</p>
<p>برای مثال، اگر a برابر ۴ باشد و x برابر ۳ :</p>
<p>&gt;&gt;&gt; a = 4</p>
<p>&gt;&gt;&gt; x = 3</p>
<p>&gt;&gt;&gt; y = (x + a/x) / 2</p>
<p>&gt;&gt;&gt; y</p>
<p>2.16666666667</p>
<p>نتیجه به جواب صحیح نزدیک‌تر می شود(رادیکال 4 = 2). اگر ما این روند را با
مقدار تخمین جدید تکرار کنیم جواب نزدیک‌تری خواهیم یافت:</p>
<p>&gt;&gt;&gt; x = y</p>
<p>&gt;&gt;&gt; y = (x + a/x) / 2</p>
<p>&gt;&gt;&gt; y</p>
<p>2.00641025641</p>
<p>بعد از چند بروزرسانی، تخمین نسبتاً دقیق است:</p>
<p>&gt;&gt;&gt; x = y</p>
<p>&gt;&gt;&gt; y = (x + a/x) / 2</p>
<p>&gt;&gt;&gt; y</p>
<p>2.0001024003</p>
<p>&gt;&gt;&gt; x = y</p>
<p>&gt;&gt;&gt; y = (x + a/x) / 2</p>
<p>&gt;&gt;&gt; y</p>
<p>2.00000000003</p>
<p>به طور عمومی ما نمی‌دانیم چه تعداد گام رو به جلو برای رسیدن به جواب درست
لازم است، اما می‌دانیم ه زمانی به آن می‌رسیم زیرا که تغییرات تخمین متوقف
می‌شود:</p>
<p>&gt;&gt;&gt; x = y</p>
<p>&gt;&gt;&gt; y = (x + a/x) / 2</p>
<p>&gt;&gt;&gt; y</p>
<p>2.0</p>
<p>&gt;&gt;&gt; x = y</p>
<p>&gt;&gt;&gt; y = (x + a/x) / 2</p>
<p>&gt;&gt;&gt; y</p>
<p>2.0</p>
<p>زمانی که y == x ، می‌توانیم توقف کنیم.اینجا یک حلقه است که با یک تخمین
اولیه، x، و بهبود می‌یابد.تا زمانی که تغییرات متوقف شود:</p>
<p>print(x)</p>
<p>y = (x + a/x) / 2</p>
<p>if y == x:</p>
<p>break</p>
<p>x = y</p>
<p>[^4]: Infinite loop</p>
				
				

			</div>

		</main>
	
		<footer class="oh">
		
			
			
			<a class="right" href="http://www.mkdocs.org">ساخته شده توسط: MkDocs.</a>

		</footer>
	
	</div>
	
	<!--
		To include static assets from our theme, just add
		.. beforehand which will be the relative path to
		the root of the documentation.
	-->
	<script src="../js/theme.js"></script>

	<!--
		extra_javascript contains paths to JavaScript files in the
		users documentation directory or a list of JavaScript files
		defined in their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_javascript
	-->
	

</body>
</html>