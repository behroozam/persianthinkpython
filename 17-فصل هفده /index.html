<!--
	This Basic theme serves as an example for how to create other
	themes by demonstrating the features with minimal HTML and CSS.
	Comments like this will be through the code to explain briefly
	what each feature is and point you to the MkDocs documentation
	to find out more.
-->
<!DOCTYPE html>
<head>
	
	<meta charset="UTF-8" />
	
	<!--
		The page_title contains the title for a page as shown in the navigation.
		Site name contains the name as defined in the mkdocs.yml
	-->
	<title>17 فصل هفده  - تفکر پایتونی</title>

	<!--
		Support custom favicon support.
		http://www.mkdocs.org/user-guide/configuration/#site_favicon
	-->
	
		<link rel="shortcut icon" href="../img/favicon.ico">
	

	<!--
		You can include external assets of course, but be aware that it means the
		documentation may not work well offline.
	-->
	<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">

	<link rel="stylesheet" href="../css/theme.css">

	<!--
		extra_ess contains paths to CSS files in the users
		documentation directory or a list of CSS files defined in
		their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_css
	-->
	

	<link rel="stylesheet" href="../css/darkula.css">
	<script src="../js/highlight.pack.js"></script>
	
	<!--
		Include Google Analytics tracking code.

		http://www.mkdocs.org/user-guide/configuration/#google_analytics
	-->
	

	
	
</head>

<body>

	<div class="sidebar left">

		<ul>
		
			
				
				

	<li >
	
		<a href="..">Home</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../01-فصل اول/">01 فصل اول</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../02-فصل دوم/">02 فصل دوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../03-فصل سوم/">03 فصل سوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../04-فصل چهارم/">04 فصل چهارم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../05-فصل پنجم/">05 فصل پنجم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../06-فصل ششم/">06 فصل ششم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../07-فصل هفتم/">07 فصل هفتم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../08-فصل هشتم/">08 فصل هشتم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../09-فصل نهم/">09 فصل نهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../10-فصل دهم/">10 فصل دهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../11-فصل یازدهم/">11 فصل یازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../12-فصل دوازدهم/">12 فصل دوازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../13-فصل سیزدهم/">13 فصل سیزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../14-فصل چهاردهم/">14 فصل چهاردهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../15-فصل پانزدهم/">15 فصل پانزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../16-فصل شانزده/">16 فصل شانزده</a>
		
	</li>


			
			
				
				

	<li class="active">
	
		<a href="./">17 فصل هفده </a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../18-فصل هجده/">18 فصل هجده</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../19-فصل نوزده/">19 فصل نوزده</a>
		
	</li>


			
			
		
		</ul>
		
	</div>
	
	<div class="body rel right">
	
		<header>
		
			<div class="right">
			
				<h1>17 فصل هفده  - تفکر پایتونی</h1>
			
			</div>
		
			<div role="search" class="left">
			
				<form action="../search.html" class="rel" method="get">
				
					<input type="text" name="q" placeholder="جستجو" />
					
					<input type="submit" class="abs search-submit" value="" />
					
				</form>
				
			</div>
		
		</header>
		
		<main class="rel oh">
		
			
		
				<div class="left toc">
				
					<ul>
						
						
							
							<li class="title">
							
								<a href="#_1">#### ۱۷.۱ ویژگی‌های شی گرایی</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_2">#### ۱۷.۲ پرینت کردن اشیاء</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_3">#### ۱۷.۳.یک مثال دیگر</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_4">#### ۱۷.۴ یک مثال پیچیده تر</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#init">#### ۱۷.۵ متد init</a>
								
							</li>
							
							
							
						
						
					</ul>
					
				</div>
			
			
			
			<div class="right content">
		
				
					
					<hr />
<p><strong>باسمه تعالی</strong></p>
<p><strong>کلاسها و متدها</strong></p>
<p><strong>با اینکه ما از امکانات شی‌گرایی پایتون استفاده کرده ایم، اما
برنامه‌هایی که در دو فصل اخیر نوشته ایم در واقع شی‌گرا نیستند زیرا آنها
رابطه میان انواع تعریف شده توسط برنامه نویس و توابعی که روی آنها عملیات
انجام می‌دهند را به نمایش نمیگذارند. قدم بعدی تبدیل این توابع به توابعی
است که این رابطه را واضح نمایش دهد.</strong></p>
<p><strong>مثالهای این فصل در آدرس</strong><a href="http://thinkpython2.com/code/Time2.py"><strong>
</strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>http</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>://</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>thinkpython</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>2.</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>com</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>/</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>code</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>/</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>Time</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>2.</em></strong></a><a href="http://thinkpython2.com/code/Time2.py"><strong><em>py</em></strong></a><strong>
و جوابهای تمرینات در آدرس</strong><a href="http://thinkpython2.com/code/Point2_soln.py"><strong>
</strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>http</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>://</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>thinkpython</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>2.</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>com</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>/</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>code</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>/</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>Point</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>2_</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>soln</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>.</em></strong></a><a href="http://thinkpython2.com/code/Point2_soln.py"><strong><em>py</em></strong></a><strong>
در دسترس هستند.</strong></p>
<h6 id="_1">#### <span id="anchor"></span><strong>۱۷.۱ ویژگی‌های شی گرایی</strong></h6>
<p><strong>پایتون یک زبان شی‌گرا است. این بدین معناست که ویگژگی‌های یک زبان
شی‌گرا را داراست. این ویژگی‌ها عبارتند از</strong></p>
<ul>
<li><strong>برنامه‌ها حاوی تعریف کلاس‌ها و متدها هستند.</strong></li>
<li>
<hr />
</li>
<li><strong>اکثر کارهای محاسباتی در قالب انجام عملیات روی اشیا بیان می‌شوند</strong></li>
<li>
<hr />
</li>
<li><strong>اشیا موارد دنیای واقعی را به نمایش گذاشته و متدها معادل نحوه تعامل
    موارد در دنیای واقعی هستند.</strong></li>
</ul>
<p><strong>به عنوان مثلا کلاس Time تعریف شده در فصل ۱۶ معادل نحوه‌ای است که افراد
در دنیای واقعی زمان را ثبت می‌کنند. توابع تعریف شده نیز معادل عملیاتی
است که افراد با زمان انجام می‌دهند. همچنین، کلاسهای Point و Rectangle در
فصل ۱۵ معادل مفاهیم ریاضی نقطه و مستطیل هستند.</strong></p>
<p><strong>تاکنون ما از هیچ یک از امکاناتی که پایتون برای پشیبانی از شی‌گرایی
ارائه می‌دهد استفاده نکرده‌ایم. استفاده از این ویژگی‌ها الزامی نیستند.
بسیاری از آنها یک syntax جایگزین برای چیزهایی است که هم‌اکنون انجام
داده‌ایم. اما در بسیاری از مواقع، این جایگزین موجز تر بوده و دقیق تر
ساختار برنامه را بیان می‌دارد.</strong></p>
<p><strong>به عنوان مثال در Time1.py هیچ ارتباط واضحی میان تعریف کلاس و تعریف
توابع زیر وجود ندارند. با انجام چند آزمایش، مشخص می‌شود که هریک از توابع
حداقل یک آرگومان از یک شیء از نوع Time دارد.</strong></p>
<p><strong>این آزمایش انگیزه اولیه استفاده از متدها است. متد تابعی است که به کلاس
خاصی تعلق دارد. ما متدهایی برای رشته‌ها، لیست‌ها، دیکشنری‌ها و tupleها
دیده‌ایم. در این فصل ما متدها را برای انواع تعریف شده توسط برنامه نویس‌
تعریف می‌کنیم.</strong></p>
<p><strong>متدها از نظر نحوی همانند توابع هستند، اما دو تفاوت سینتکسی وجود
دارد:</strong></p>
<ul>
<li><strong>متدها داخل کلاس تعریف می‌شوند. هدف از تعریف داخل کلاس نمایش صریح
    کلاس و متدهاست.</strong></li>
<li>
<hr />
</li>
<li><strong>سینتکس فرواخوانی متدها نیز از توابع متفاوت است.</strong></li>
</ul>
<p><strong>در چند بخش آتی، ما توابع فصلهای گذشته را تبدیل متد خواهیم کرد. این
تبدیل کاملا ساده است و شما نیز می‌توانید هر تابعی را با انجام قدم‌هایی
تبدیل کنید. اگر شما با تبدیل تابع به متد و بالعکس راحت باشید می‌توانید
انتخاب کنید که کدام شکل برای کار شما بهتر است.</strong></p>
<h6 id="_2">#### <span id="anchor-1"></span><strong>۱۷.۲ پرینت کردن اشیاء</strong></h6>
<p><strong>در فصل ۱۶ ما کلاسی به اسم Time تعریف کردیم و در بخش ۱۶.۱ تابعی به اسم
print_time توسعه دادیم:</strong></p>
<hr />
<hr />
<hr />
<p><strong>برای فراخوانی این تابع باید شما یک شی از نوع Time را به عنوان آرگومان
به تابع بدهید</strong></p>
<hr />
<hr />
<hr />
<p><strong>تنها کار برای تبدیل print_time به یک متد، این است که تعریف تابع را
درون تعریف کلاس ببریم. به تغییر در فرورفتگی کد دقت کنید:</strong></p>
<hr />
<hr />
<hr />
<p><strong>حالا دو راه برای فراخوانی متد print_time وجود دارد. اولین راه(غیر
معمول) عبارت است از:</strong></p>
<hr />
<hr />
<hr />
<p><strong>در این نحوه استفاده از نقطه، Time اسم کلاس است و print_time نام متد
است. start به عنوان یک پارامتر داده می‌شود.</strong></p>
<p><strong>راه دوم(که کوتاه تر هم هست) این است که سینتکس متد استفاده کنیم:</strong></p>
<hr />
<hr />
<hr />
<p><strong>در این نحوه استفاده از نقطه، print_time (دوباره) اسم متد است و start
شی ای است که متد از آن فرواخوانی شده است. نام دیگر این شی موضوع نیز هست.
همانند موضوع یک جمله که نشان‌دهنده محتوای جمله است، موضوع یک متد نیز
محتوایی است که متد از روی آن فروخوانی می‌شود.</strong></p>
<p><strong>درون متد موضوع به اولین پارامتر تخصیص داده می‌شود، پس در این حالت
start به time تخصیص داده می‌شود.</strong></p>
<p><strong>بصورت قراردادی اولین پارامتر متد self نامیده می‌شود.پس به شکل معمول تر
متد print_time بصورت زیر است</strong></p>
<hr />
<hr />
<hr />
<p><strong>دلیل این قرارداد یک استعاره غیر واضح است:</strong></p>
<ul>
<li><strong>سینتکس فرواخوانی تابع، print_time(start) پیشنهاد می‌دهد که تابع
    یک عنصر عامل است. مانند این است که بگویمم «ای print_time، این شی
    مورد نیاز تو برای پرینت کردن است.»</strong></li>
<li>
<hr />
</li>
<li><strong>در برنامه نویسی شی گرا، اشیا عناصر فعال هستند. در یک فرواخوانی متد
    نوع مانند start.print_time() می‌گوید که «ای start، لطفا خودت را
    پرینت کن»</strong></li>
</ul>
<p><strong>این تغییر نحوه نگاه ممکن است مودبانه تر باشد اما بصورت واضح نشان
نمی‌دهد که کاربردی تر است. در مثالهایی که تا کنون دیدم، ممکن است اینگونه
نباشد. اما در مواردی تغییر در مسئولیت از توابع به اشیا این امکان را
فراهم می‌آورد که توابع (یا متدهای) تطبیق پذیر تری داشته باشیم. همچنین
استفاده مجدد از کد و نگهداری آن آسانتر می‌شود.</strong></p>
<p><strong>به عنوان تمرین تابع time_to_int (بخش ۱۶.۴) را تبدیل به یک متد کنید.
ممکن است که مشتاق شوید که تابع int_to_time را نیز تبدیل به متد کنید
اما این عمل منتطق نیست چون شی برای اجرای این متد رویش وجود ندارد</strong></p>
<h6 id="_3">#### <span id="anchor-2"></span><strong>۱۷.۳.یک مثال دیگر</strong></h6>
<p><strong>این یک نسخه دیگر تابع version(بخش ۱۶.۳) که به عنوان یک متد نوشته شده
است:</strong></p>
<hr />
<hr />
<hr />
<p><strong>در این نسخه فرض بر این است که time_to_int به عنوان یک متد نوشته شده
است. همچنین توجه داشته باشید که این یک متد کامل است نه یک تغییر دهنده.</strong></p>
<p><strong>نحوه فراخوانی این متد به شکل زیر است:</strong></p>
<hr />
<hr />
<hr />
<p><strong>شی موضوع به عنوان پارامتر اول که همان self است تخصیص داده می‌شود.
آرگومان 1337 به پارامتر دوم تخصیص داده می‌شود.</strong></p>
<p><strong>این مکانیزم گیج کننده است، هنگامی که شما خطایی انجام می‌دهید. به عنوان
مثال اگه شما increment را با دو آرگومان فراخوانی کنید شما خواهید داشت:</strong></p>
<hr />
<hr />
<hr />
<p><strong>این پیغام خطا در ابتدا گیج کننده است، بخاطر اینکه تنها دو آرگومان درون
پرانتر وجود دارد. اما موضوع نیز به عنوان یک آرگومان در نظر گرفته می‌شود،
پس در مجموع سه آرگومان وجود دارد.</strong></p>
<p><strong>ضمنا، یک آرگومان موضعی آرگومانی است که نام پارامتر را با خود ندارد.
این بدین معناست که یک آرگومان با کلمه کلیدی نیست. در این فرواخونی
تابع:</strong></p>
<hr />
<hr />
<hr />
<p><strong>آرگومانهای parrot و cage آرگومانهای موضعی و deae آرگومان کلمه کلیدی
است.</strong></p>
<h6 id="_4">#### <span id="anchor-3"></span><strong>۱۷.۴ یک مثال پیچیده تر</strong></h6>
<p><strong>بازنویسی تابع is_after(بخش ۱۶.۱) اندکی پیچده تر است، بخاطر اینکه این
تابع دو شی از نوع Time به عنوان پارامتر دریافت می‌کند. در این حالت
قرارداد این است که نام اولین پارامتر seft و دومین پارامتر other است:</strong></p>
<hr />
<hr />
<hr />
<p><strong>برای استفاده از این متد، شما بایستی آنرا روی یک شی فراخوانی کرده و شی
دوم را به عنوان پارامتر استفاده کنید</strong></p>
<hr />
<hr />
<hr />
<p><strong>یکی از حسن‌های این سنتکس این است که تقریبا مثل انگلیسی خوانده می‌شود
«end is after start»</strong></p>
<h6 id="init">#### <span id="anchor-4"></span><strong>۱۷.۵ متد init</strong></h6>
<p><strong>متد init (که مخفف initialization)است، یک متد ویژه است که وقتی یک شی
ساخته می‌شود فراخوانی می‌شود. نام کامل این متد __init__ (دو
underscore بعد init و بعد دو underscore دیگر)است. متد init برای کلاس
Timeممکن است چیزی شبیه به این باشد.</strong></p>
<hr />
<hr />
<hr />
<p><strong>بطور معمول پارامترهای متد __init__ نامی شبیه ویژگی‌ها کلاس دارند.
عبارت زیر :</strong></p>
<hr />
<hr />
<hr />
<p><strong>پارامتر hour را به عنوان مقدار یکی از ویژگی‌ها self ذخیره می‌کند.</strong></p>
<p><strong>پارامترها اختیاری هستند یعنی اگر شما Time را بدون آرگومان فراخوانی
کنید مقادیر اولیه را دریافت می‌کنید.</strong></p>
<hr />
<hr />
<hr />
<p><strong>اگر یک پارامتر بدهید، ساعت را مقدار خواهید داد:</strong></p>
<hr />
<hr />
<hr />
<p><strong>اگر دو پارامتر را مقدار دهید، ساعت و دقیقه را مقدار داده اید:</strong></p>
<hr />
<hr />
<hr />
<p><strong>اگر سه پارامتر بدهید هر سه پارامتر اولیه نادیده گرفته خواهد شد.</strong></p>
<p><strong>به عنوان تمرین، متد init کلاس Point که x و y را به عنوان پارامتر
اختیاری گرفته و به ویژگی‌های مرتبطشان تخصیص می‌دهد را بنویسید</strong></p>
<hr />
<p><strong>۱۷.۶ متد __str__</strong></p>
<p>متد __str__ یک متد خاص مانند __init__ است که وظیفه‌اش برگرداندن
نسخه رشته ای از یک شی است.</p>
<p>به طور مثال این متد str برای شی Time است:</p>
<p># inside class Time:\
\
 def __str__(self):\
 return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)</p>
<p>وقتی شما یک شی را پرینت میکنید، پایتون متد str را فراخوانی میکند:</p>
<p>&gt;&gt;&gt; time = Time(9, 45)\
&gt;&gt;&gt; print time\
09:45:00\</p>
<p>هرگاه من کلاس تازه‌ای در پایتون مینویسم، ابتدا متد init را میسازم که کار
نمونه سازی شی را آسان تر میکند و بعد از str را مینویسم که کار عیب‌یابی
(Debugging) را ساده تر میکند.</p>
<p><strong>تمرین ۳</strong></p>
<p>برای کلاس Point یک متد str بنویسید. از این کلاس یک شی درست کنید و آن را
پرینت کنید.</p>
<p><strong>۱۷.۷ Operator Overloading</strong></p>
<p>با تعریف متد های مخصوص دیگر، میتوانید رفتار دیگر عملگرها روی انواع
(Type) تعریف شده توسط کاربر مشخص کنید. به طور مثال اگر متد __add__
را روی کلاس Time تعریف کنید میتوانید از عملگر + روی اشیای Time استفاده
کنید.</p>
<p>مثال زیر شکلی از پیاده سازی نمونه ذکر شده است:</p>
<p># inside class Time:\
\
 def __add__(self, other):\
 seconds = self.time_to_int() + other.time_to_int()\
 return int_to_time(seconds)</p>
<p>و به این شکل قابل استفاده است:</p>
<p>&gt;&gt;&gt; start = Time(9, 45)\
&gt;&gt;&gt; duration = Time(1, 35)\
&gt;&gt;&gt; print start + duration\
11:20:00</p>
<p>وقتی در پایتون از عملگر + استفاده میکنید پایتون __add__ را فراخوانی
میکند. وقتی نتیجه را پرینت میکنید، پایتون __str__ را فراخوانی میکند.
در نتیجه اتفاقات زیادی در پشت صحنه در حال رخ دادن است!</p>
<p>تغییر رفتار عملگر به شکلی که روی انواع تعریف شده توسط کاربر کار کند
Operator Overloading نامیده میشود. برای هر عملگر در پایتون یک متد مخصوص
برای پاسخگویی وجود دارد. برای اطلاعات بیشتر به این صفحه مراجعه کنید:
<a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>http</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>://</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>docs</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>.</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>python</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>.</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>org</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>/2/</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>reference</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>/</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>datamodel</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>.</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>html</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>#</em></a><a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><em>specialnames</em></a></p>
<p><strong>تمرین ۴</strong></p>
<p>یک متد add برای کلاس Point بنویسید.</p>
<p><strong>۱۷.۸ Type-based dispatch</strong></p>
<p>در بخش قبل ما دو شی Time ایجاد کردیم،‌ ولی شاید بخواهید یک عدد صحیح به
شی Time اضافه کنید. کد زیر نسخه‌ای از __add__ است که نوع other را
بررسی میکند و یکی از add_time یا increment را خطاب میکند:</p>
<p># inside class Time:\
\
 def __add__(self, other):\
 if isinstance(other, Time):\
 return self.add_time(other)\
 else:\
 return self.increment(other)\
\
 def add_time(self, other):\
 seconds = self.time_to_int() + other.time_to_int()\
 return int_to_time(seconds)\
\
 def increment(self, seconds):\
 seconds += self.time_to_int()\
 return int_to_time(seconds)</p>
<p>تابع توکار (built-in) isinstance یک مقدار و شی کلاس را میگیرد و اگر
مقدار وارد شده نمونه‌ای از کلاس باشد مقدار True را برمیگرداند.</p>
<p>اگر other یک شی Time باشد، __add__ تابع add_time را خطاب میکند. در
غیر اینصورت فرض بر این خواهد بود که پارامتر عدد است و تابع increment را
فراخوانی میکند. به این کار type-based dispatch میگوید چون محاسبه را به
متدهای مختلف بر اساس نوع آرگومان‌ها مخابره میکند.</p>
<p>این مثالی از استفاده عملگر + در انواع مختلف است:</p>
<p>&gt;&gt;&gt; start = Time(9, 45)\
&gt;&gt;&gt; duration = Time(1, 35)\
&gt;&gt;&gt; print start + duration\
11:20:00\
&gt;&gt;&gt; print start + 1337\
10:07:17</p>
<p>متاسفانه این شکل پیاده‌سازی جمع قابلیت جابجایی ندارد. اگر عدد صحیح اولین
مقدار باشد، این اتفاق میفتد:</p>
<p>&gt;&gt;&gt; print 1337 + start\
TypeError: unsupported operand type(s) for +: 'int' and 'instance'</p>
<p>مشکل اینجا این است که در اینجا پایتون به جای اینکه از Time بخواهد که یک
عدد صحیح به آن اضافه کند، از یک عدد صحیح میخواهد که یک شی Time را با آن
جمع کند، و عدد صحیح نمیداند که چطور اینکار را انجام دهد. ولی یک راه‌حل
جالب برای رفع این مشکل وجود دارد: استفاده متد __radd__ که مخفف
right-side add (جمع سمت راست) است. این متد هنگامی فراخوانی میشود که شی
Time در سمت راست یک جمع ظاهر میشود. این شکلی از پیاده سازی است:</p>
<p># inside class Time:\
\
 def __radd__(self, other):\
 return self.__add__(other)\</p>
<p>و اینگونه استفاده میشود:</p>
<p>&gt;&gt;&gt; print 1337 + start\
10:07:17</p>
<p><strong>تمرین ۵</strong></p>
<p>یک متد add برای کلاس Point بنویسید که یا یک شی Point بگیرد یا یک چندتایی
(Tuple):</p>
<ul>
<li>اگر مقدار دوم Point بود، متد باید یک شی جدید از Point بسازد که مقدار
    x مختصات جمع مقادیر x عملوند ها باشد، به همین شکل برای مختصات y.</li>
<li>اگر عملوند دوم یک چندتایی باشد، متد باید المان اول چندتایی را به x و
    المان دوم را به y اضافه میکند، و یک Point جدید به عنوان
    نتیجه برگرداند.</li>
</ul>
<p><strong>۱۷.۹ چند ریختی (Polymorphism)</strong></p>
<p>Type-based dispatch وقتی به درد میخورد که واقعا مورد نیاز باشد، ولی
(خوشبختانه) همیشه مورد نیاز نیست. معمولا میتوانید با نوشتن توابع مختلف
با آرگومان ها با انواع مختلف به خوبی کار کنید.</p>
<p>بیشتر توابعی که ما برای رشته ها نوشتیم برای هر شکلی از دنباله کار میکند.
به عنوان مثال، در بخش ۱۱.۱ ما از histogram برای شمردن دفعات تکرار یک
کاراکتر در یک کلمه استفاده کردیم.</p>
<p>def histogram(s):\
 d = dict()\
 for c in s:\
 if c not in d:\
 d[c] = 1\
 else:\
 d[c] = d[c]+1\
 return d\</p>
<p>این تابع برای لیست ها، چندتایی ها و حتی دیکشنری ها کار میکند، تا وقتی که
عناصر s قابل هش شدن باشد تا بتوان به عنوان کلید در d از آن استفاده کرد.</p>
<p>&gt;&gt;&gt; t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam']\
&gt;&gt;&gt; histogram(t)\
{'bacon': 1, 'egg': 1, 'spam': 4}</p>
<p>توابعی که میتوانند با چند نوع مختلف کار کنند چندریختی نامیده میشوند.
چندریختی استفاده دوباره از کد را تسهیل میکند. به طور مثال تابع توکار sum
که عناصر یک دنباله را با هم جمع میکند،‌ تا وقتی که عناصر دنباله قابلیت
جمع داشته باشند ادامه پیدا میکند.</p>
<p>از آنجا که به اشیای Time یک متد add اضافه کرده ایم، با sum کار میکنند:</p>
<p>&gt;&gt;&gt; t1 = Time(7, 43)\
&gt;&gt;&gt; t2 = Time(7, 41)\
&gt;&gt;&gt; t3 = Time(7, 37)\
&gt;&gt;&gt; total = sum([t1, t2, t3])\
&gt;&gt;&gt; print total\
23:01:00</p>
<p>به طور کلی، اگر همه عملیات داخل تابع با نوع داده شده کار کند، کل تابع با
آن نوع کار میکند.</p>
<p><strong>۱۷.۱۰ رفع مشکل</strong></p>
<p>امکان اضافه کردن ویژگی به اشیا در هر نقطه از اجرای برنامه ممکن است، ولی
اگر به تئوری انواع در برنامه احترام میگذارید، کار اشتباهیست که چند شی از
یک نوع با ویژگی های متفاوت داشته باشید. معمولا کار بهتر این است که تمام
ویژگی‌های شی در متد init آن مشخص شده باشد.</p>
<p>اگر مطمئن نیستید که یک شی یک ویژگی خاص دارد یا نه، میتوانید از تابع
توکار hasattr استفاده کندی (بخش ۱۵.۷)</p>
<p>راه دیگر دسترسی به یک ویژگی استفاده از ویژگی خاص __dict__ است که یک
دیکشنری است که نام و مقدار همه ویژگی ها را برمیگرداند:</p>
<p>&gt;&gt;&gt; p = Point(3, 4)\
&gt;&gt;&gt; print p.__dict__\
{'y': 4, 'x': 3}\</p>
<p>برای رفع مشکلات (Debugging) بهتر است این تابع را به این شکل در دسترس نگه
دارید:</p>
<p>def print_attributes(obj):\
 for attr in obj.__dict__:\
 print attr, getattr(obj, attr)</p>
<p>تابع print_attributes در دیکشنری آیتم های موجود شی گردش میکند و نام و
مقدار هر ویژگی را چاپ میکند.</p>
<p>تابع توکار getattr یک شی و نام یک ویژگی را میگیرد و مقدار ویژگی را
برمیگرداند.</p>
<p><strong>۱۷.۱۱ واسط و پیاده سازی آن</strong></p>
<p>یکی از اهداف استفاده از شی گرایی این است که نرم افزار ساختار پذیری
بیشتری داشته باشد، به این معنی که برنامه در حال کار باشد درحالی دیگر
اعضای سیستم در حال تغییرند و برنامه را طوری تغییر دهید که با نیازهای
جدید هماهنگ شوند.</p>
<p>یک الگوی طراحی که برای رسیدن به این هدف کمک میکند این است که واسط‌ها را
از پیاده‌سازی‌ها جدا کنید. برای اشیا، اینکار به این معنی است که متدهای
کلاس نباید به ویژگی‌های آن وابسته باشد.</p>
<p>به طور مثال در این بخش ما کلاسی ایجاد میکنیم که زمان را نشان میدهد.
متدهای موجود این کلاس شامل time_to_int، is_after و add_time است.</p>
<p>این متدها را میتوانیم به اشکال مختلف توسعه دهیم. جزییات پیاده سازی بستگی
به این دارد که ما چطور زمان را نشان میدهیم. در اینجا، ویژگی‌های شی Time
شامل hour, minute و second است.</p>
<p>به عنوان راه حل جانبی ما میتوانیم به جای استفاده از این ویژگی ها از یک
عدد صحیح که تعداد ثانیه‌ها از نیمه شب را نمایش میدهد استفاده کنیم.
اینطور پیاده سازی نوشتن متدهایی مثل is_after را راحت تر میکند ولی در
مقابل نوشتن برخی متدهای دیگر سخت میشود.</p>
<p>بعد از پیاده‌سازی این کلاس ممکن است یک راه پیاده‌سازی بهتری پیدا کنید.
اگر بقیه اعضای برنامه از کلاس شما استفاده میکنند پیاده سازی جدید کار پر
خطا و زمانبری خواهد بود.</p>
<p>در حالی که اگر واسط را با دقت پیاده کرده باشید میتوانید پیاده‌سازی را
عوض کنید بدون اینکه واسط را دستکاری کنید، به این معنی که بقیه اعضای
برنامه تغییر نخواهد کرد.</p>
<p>جدا کردن واسط از پیاده‌سازی به این است که باید ویژگی‌ها را مخفی کنید. کد
بقیه اعضای برنامه (خارج از تعریف کلاس) باید از متدهایی برای خواندن و
تغییر حالت شی استفاده کنند و نباید به ویژگی‌ها به طور مستقیم دسترسی
داشته باشند. به این اصول مخفی‌سازی اطلاعات (Information hiding) میگویند.
م.ش:
<a href="http://en.wikipedia.org/wiki/Information_hiding"><em>http</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>://</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>en</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>.</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>wikipedia</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>.</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>org</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>/</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>wiki</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>/</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>Information</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>_</em></a><a href="http://en.wikipedia.org/wiki/Information_hiding"><em>hiding</em></a></p>
<p><strong>تمرین ۶</strong></p>
<p>کد این بخش را دانلود کنید
(<a href="http://thinkpython.com/code/Time2.py"><em>http</em></a><a href="http://thinkpython.com/code/Time2.py"><em>://</em></a><a href="http://thinkpython.com/code/Time2.py"><em>thinkpython</em></a><a href="http://thinkpython.com/code/Time2.py"><em>.</em></a><a href="http://thinkpython.com/code/Time2.py"><em>com</em></a><a href="http://thinkpython.com/code/Time2.py"><em>/</em></a><a href="http://thinkpython.com/code/Time2.py"><em>code</em></a><a href="http://thinkpython.com/code/Time2.py"><em>/</em></a><a href="http://thinkpython.com/code/Time2.py"><em>Time</em></a><a href="http://thinkpython.com/code/Time2.py"><em>2.</em></a><a href="http://thinkpython.com/code/Time2.py"><em>py</em></a>)
و ویژگی‌های Time را به یک عدد صحیح نمایش دهنده ثانیه‌ها از نیمه شب تغییر
دهید. سپس متدها را تغییر دهید (و تابع int_to_time) تا با پیاده‌سازی
جدید کار کند. کد تست main را اصلا تغییر ندهید. وقتی همه چیز تمام شد
خروجی باید دقیقا مثل قبل باشد. راه حل:
<a href="http://thinkpython.com/code/Time2_soln.py"><em>http</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>://</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>thinkpython</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>.</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>com</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>/</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>code</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>/</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>Time</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>2_</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>soln</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>.</em></a><a href="http://thinkpython.com/code/Time2_soln.py"><em>py</em></a></p>
<p><strong>۱۷.۱۲ دایره لغات</strong></p>
<p><strong>زبان شی گرا (object-oriented language):</strong></p>
<p>زبانی که امکاناتی مانند کلاس های تعریف شده توسط کاربر و syntax متد را در
اختیار میگذارد که برنامه نویسی شی گرا را آسان میکند.</p>
<p><strong>برنامه نویسی شی گرا (object-oriented programming):</strong></p>
<p>یک شیوه برنامه نویسی که در آن داده و عملیاتی که آن را تغییر میدهند در
کلاس‌ها و متدها مرتب شده است.</p>
<p><strong>متد (method):</strong></p>
<p>تابعی که در تعریف یک کلاس نوشته شده است و در نمونه‌های آن کلاس قابل
فراخوانی است.</p>
<p><strong>subject:</strong></p>
<p>Object ای که متد روی آن اجرا شده است.</p>
<p><strong>operator overloading:</strong></p>
<p>تغییر رفتار یک عملگر مثل + تا روی یک نوع تعریف شده توسط کاربر کار کند.</p>
<p><strong>type-based dispatch:</strong></p>
<p>یک الگوی برنامه نویسی که نوع عملوند را بررسی میکند و بر اساس آن توابع
مختلف را صدا میزند.</p>
<p><strong>چند ریختی (polymorphic):</strong></p>
<p>اشاره به نوعی تابع که با انواع مختلف کار میکند.</p>
<p><strong>مخفی سای اطلاعات (information hiding):</strong></p>
<p>اصلی که در آن واسط ارائه شده توسط یک Object نباید به پیاده ساری وابسته
باشد، به طور دقیق تر، ویژگی های Object.</p>
<p><strong>۱۷.۱۳ تمرینات</strong></p>
<p><strong>تمرین ۷</strong></p>
<p>این تمرین برای پیدا کردن یکی از رایج‌ترین،‌ در حالی که به سختی قابل پیدا
کردن است، خطاهای پایتون است. یک تعریف از کلاسی به اسم Kangaroo بنویسید
که متدهای زیر را دارد.</p>
<p>۱. متد __init__ که در آن ویژگی pouch_contents با یک لیست خالی
مقداردهی کند.</p>
<p>۲. متدی با نام put_in_pouch که یک Object با هر نوعی میگیرد و به
pouch_contents اضافه میکند.</p>
<p>۳. متد __str__ که یک خروجی رشته‌ای از شی Kangaroo و pouch_contents
برمیگرداند.</p>
<p>کد خود را با ایجاد دو شی Kangaroo و دادن دو مقدار kanga و roo به آن و
اضافه کردن roo به kanga بررسی کنید.</p>
<p>کد
<a href="http://thinkpython.com/code/BadKangaroo.py"><em>http</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>://</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>thinkpython</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>.</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>com</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>/</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>code</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>/</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>BadKangaroo</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>.</em></a><a href="http://thinkpython.com/code/BadKangaroo.py"><em>py</em></a>
را دانلود کنید. این راه حل شامل یک باگ بزرگ و اذیت کننده هم هست! باگ را
پیدا و رفع کنید.</p>
<p>اگر راه حلی پیدا نکردید
<a href="http://thinkpython.com/code/GoodKangaroo.py"><em>http</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>://</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>thinkpython</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>.</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>com</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>/</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>code</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>/</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>GoodKangaroo</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>.</em></a><a href="http://thinkpython.com/code/GoodKangaroo.py"><em>py</em></a>
را دانلود کنید که مشکل را توضیح میدهد و برای رفع آن راه حلی پیشنهاد
میدهد.</p>
<p><strong>تمرین ۸</strong></p>
<p>Visual یک ماژول پایتون است که گرافیک سه بعدی را در اختیار قرار میدهد.
این ماژول همیشه در نصب پایتون وجود ندارد در نتیجه ممکن است نیاز باشد که
آن را دانلود و نصب کنید.
(<a href="http://vpython.org/"><em>http</em></a><a href="http://vpython.org/"><em>://</em></a><a href="http://vpython.org/"><em>vpython</em></a><a href="http://vpython.org/"><em>.</em></a><a href="http://vpython.org/"><em>org</em></a><a href="http://vpython.org/"><em>/</em></a>)</p>
<p>مثال زیر یک فضای سه بعدی به طول و عرض و ارتفاع ۲۵۶ واحد ایجاد میکند و
مرکز آن را روی نقطه (۱۲۸،۱۲۸،۱۲۸) قرار میدهد. سپس یک کره آبی رسم میکند.</p>
<p><em>from visual import *\
\
scene.range = (256, 256, 256)\
scene.center = (128, 128, 128)\
\
color = (0.1, 0.1, 0.9) # mostly blue\
sphere(pos=scene.center, radius=128, color=color)</em></p>
<p>color یک چندتایی RGB است؛ به این معنی که عناصر قرمز، سبز، آبی هستند و
مقادیر بین ۰.۰ و ۱.۰ هستند.
(<a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>http</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>://</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>en</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>.</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>wikipedia</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>.</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>org</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>/</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>wiki</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>/</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>RGB</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>_</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>color</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>_</em></a><a href="http://en.wikipedia.org/wiki/RGB_color_model"><em>model</em></a>)</p>
<p>اگر این برنامه را اجرا کنید، باید یک صفحه با پس زمینه سیاه و یک کره آبی
رنگ مشاهده کنید. اگر کلید وسط را بالا و پایین کنید میتوانید بزرگ و کوچک
نمایی کنید. همچنین میتوانید صفحه را با نگه داشتن کلید راست و کشیدن صفحه
بچرخانید، ولی با وجود تنها یک کره در محیط نمیتوان چرخش را تشخیص داد.</p>
<p>حلقه زیر یک مکعب پر از کره ایجاد میکند:</p>
<p><em>t = range(0, 256, 51)\
for x in t:\
 for y in t:\
 for z in t:\
 pos = x, y, z\
 sphere(pos=pos, radius=10, color=color)</em></p>
<p>۱. این کد را در یک اسکریپت قرار دهید و از اجرای آن اطمینان حاصل کنید.</p>
<p>۲. برنامه را طوری تغییر دهید که هر کره بسته به جایگاه آن رنگش مشخص شود.
دقت کنید که فضا از ۰ تا ۲۵۵ است و چندتایی RGB از ۰.۰ تا ۱.۰.</p>
<p>۳.
<a href="http://thinkpython.com/code/color_list.py"><em>http</em></a><a href="http://thinkpython.com/code/color_list.py"><em>://</em></a><a href="http://thinkpython.com/code/color_list.py"><em>thinkpython</em></a><a href="http://thinkpython.com/code/color_list.py"><em>.</em></a><a href="http://thinkpython.com/code/color_list.py"><em>com</em></a><a href="http://thinkpython.com/code/color_list.py"><em>/</em></a><a href="http://thinkpython.com/code/color_list.py"><em>code</em></a><a href="http://thinkpython.com/code/color_list.py"><em>/</em></a><a href="http://thinkpython.com/code/color_list.py"><em>color</em></a><a href="http://thinkpython.com/code/color_list.py"><em>_</em></a><a href="http://thinkpython.com/code/color_list.py"><em>list</em></a><a href="http://thinkpython.com/code/color_list.py"><em>.</em></a><a href="http://thinkpython.com/code/color_list.py"><em>py</em></a>
را دانلود کنید و تابع read_colors تا یک لیست رنگ های موجود در سیستم را
ایجاد و نام و مقادیر RGB آن را بگیرید. به ازای هر نام رنگ یک کره رسم
کنید که جایگاه آن وابسته به مقدار RGB آن باشد.</p>
<p>راه حل من:‌
<a href="http://thinkpython.com/code/color_space.py"><em>http</em></a><a href="http://thinkpython.com/code/color_space.py"><em>://</em></a><a href="http://thinkpython.com/code/color_space.py"><em>thinkpython</em></a><a href="http://thinkpython.com/code/color_space.py"><em>.</em></a><a href="http://thinkpython.com/code/color_space.py"><em>com</em></a><a href="http://thinkpython.com/code/color_space.py"><em>/</em></a><a href="http://thinkpython.com/code/color_space.py"><em>code</em></a><a href="http://thinkpython.com/code/color_space.py"><em>/</em></a><a href="http://thinkpython.com/code/color_space.py"><em>color</em></a><a href="http://thinkpython.com/code/color_space.py"><em>_</em></a><a href="http://thinkpython.com/code/color_space.py"><em>space</em></a><a href="http://thinkpython.com/code/color_space.py"><em>.</em></a><a href="http://thinkpython.com/code/color_space.py"><em>py</em></a></p>
				
				

			</div>

		</main>
	
		<footer class="oh">
		
			
			
			<a class="right" href="http://www.mkdocs.org">ساخته شده توسط: MkDocs.</a>

		</footer>
	
	</div>
	
	<!--
		To include static assets from our theme, just add
		.. beforehand which will be the relative path to
		the root of the documentation.
	-->
	<script src="../js/theme.js"></script>

	<!--
		extra_javascript contains paths to JavaScript files in the
		users documentation directory or a list of JavaScript files
		defined in their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_javascript
	-->
	

</body>
</html>