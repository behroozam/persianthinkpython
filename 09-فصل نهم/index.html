<!--
	This Basic theme serves as an example for how to create other
	themes by demonstrating the features with minimal HTML and CSS.
	Comments like this will be through the code to explain briefly
	what each feature is and point you to the MkDocs documentation
	to find out more.
-->
<!DOCTYPE html>
<head>
	
	<meta charset="UTF-8" />
	
	<!--
		The page_title contains the title for a page as shown in the navigation.
		Site name contains the name as defined in the mkdocs.yml
	-->
	<title>09 فصل نهم - تفکر پایتونی</title>

	<!--
		Support custom favicon support.
		http://www.mkdocs.org/user-guide/configuration/#site_favicon
	-->
	
		<link rel="shortcut icon" href="../img/favicon.ico">
	

	<!--
		You can include external assets of course, but be aware that it means the
		documentation may not work well offline.
	-->
	<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">

	<link rel="stylesheet" href="../css/theme.css">

	<!--
		extra_ess contains paths to CSS files in the users
		documentation directory or a list of CSS files defined in
		their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_css
	-->
	

	<link rel="stylesheet" href="../css/darkula.css">
	<script src="../js/highlight.pack.js"></script>
	
	<!--
		Include Google Analytics tracking code.

		http://www.mkdocs.org/user-guide/configuration/#google_analytics
	-->
	

	
	
</head>

<body>

	<div class="sidebar left">

		<ul>
		
			
				
				

	<li >
	
		<a href="..">Home</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../01-فصل اول/">01 فصل اول</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../02-فصل دوم/">02 فصل دوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../03-فصل سوم/">03 فصل سوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../04-فصل چهارم/">04 فصل چهارم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../05-فصل پنجم/">05 فصل پنجم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../06-فصل ششم/">06 فصل ششم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../07-فصل هفتم/">07 فصل هفتم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../08-فصل هشتم/">08 فصل هشتم</a>
		
	</li>


			
			
				
				

	<li class="active">
	
		<a href="./">09 فصل نهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../10-فصل دهم/">10 فصل دهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../11-فصل یازدهم/">11 فصل یازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../12-فصل دوازدهم/">12 فصل دوازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../13-فصل سیزدهم/">13 فصل سیزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../14-فصل چهاردهم/">14 فصل چهاردهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../15-فصل پانزدهم/">15 فصل پانزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../16-فصل شانزده/">16 فصل شانزده</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../17-فصل هفده /">17 فصل هفده </a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../18-فصل هجده/">18 فصل هجده</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../19-فصل نوزده/">19 فصل نوزده</a>
		
	</li>


			
			
		
		</ul>
		
	</div>
	
	<div class="body rel right">
	
		<header>
		
			<div class="right">
			
				<h1>09 فصل نهم - تفکر پایتونی</h1>
			
			</div>
		
			<div role="search" class="left">
			
				<form action="../search.html" class="rel" method="get">
				
					<input type="text" name="q" placeholder="جستجو" />
					
					<input type="submit" class="abs search-submit" value="" />
					
				</form>
				
			</div>
		
		</header>
		
		<main class="rel oh">
		
			
		
				<div class="left toc">
				
					<ul>
						
						
							
							<li class="title">
							
								<a href="#_1">#### فصل ۹</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_2">#### مورد مطالعه: بازی واژه</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#91">#### 9.1 خواندن فهرست های واژه</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_3">#### ۹.۲ تمرین ها</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_4">#### ۹.۳ جستجو</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_5">#### ۹.۴ حلقه با اندیس ها</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_6">#### ۹.۵ اشکال زدایی</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_7">#### ۹.۶ واژه نامه</a>
								
							</li>
							
							
							
						
							
							<li class="title">
							
								<a href="#_8">#### تمرین‌ها ۹.۷</a>
								
							</li>
							
							
							
						
						
					</ul>
					
				</div>
			
			
			
			<div class="right content">
		
				
					
					<h6 id="_1">#### <span id="anchor"></span>فصل ۹</h6>
<h6 id="_2">#### <span id="anchor-1"></span>مورد مطالعه: بازی واژه</h6>
<p>این بخش مورد مطالعه دوم را ارائه می دهد، که دربرگیرنده حل معمای واژگان
بوسیله جستجو برای واژگان می‌باشد که ویژگی‌های خاصی دارند. برای نمونه، ما
درازترین عبارت واروخوانه (palindrome) در انگلیسی را پیدا خواهیم کرد و
واژگانی را جستجو خواهیم کرد که حروف شان به ترتیب الفبایی باشند. و من یک
برنامه‌ریزی دیگر برای توسعه برنامه ارائه خواهم کرد: کوتاه کردن یک مسأله
حل شده پیشین.</p>
<h6 id="91">#### <span id="anchor-2"></span><strong>9.1 خواندن فهرست های واژه</strong></h6>
<p>برای تمرین‌های در این بخش ما یک فهرست از واژگان انگلیسی نیاز داریم. لیست
های واژگان بسیاری در وب هستند، ولی آنی که بیشتر درخور این کار ما می‌باشد
یکی از فهرست های واژگانی است که بدست Grady Ward به عنوان بخشی از پروژه
موبی
(<a href="http://en.wikipedia.org/wiki/Moby_project"><em>http</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>://</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>en</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>.</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>wikipedia</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>.</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>org</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>/</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>wiki</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>/</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>Moby</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>_</em></a><a href="http://en.wikipedia.org/wiki/Moby_project"><em>project</em></a>)
گردهم آوری شده است. که آن لیستی از 113,809 کلمه متقاطع می باشد؛ یعنی این
که، واژه‌هایی که در معماهای کلمات متقاطع و دیگر بازی با واژه‌ها معتبر
شمرده می شوند. در مجموعه موبی، نام فایل 113809of.fic می باشد؛ شما
می‌توانید یک کپ، با یک نام ساده‌تر words.txt، از نشانی<a href="http://thinkpython2.com/code/words.txt">
</a><a href="http://thinkpython2.com/code/words.txt"><em>http</em></a><a href="http://thinkpython2.com/code/words.txt"><em>://</em></a><a href="http://thinkpython2.com/code/words.txt"><em>thinkpython</em></a><a href="http://thinkpython2.com/code/words.txt"><em>2.</em></a><a href="http://thinkpython2.com/code/words.txt"><em>com</em></a><a href="http://thinkpython2.com/code/words.txt"><em>/</em></a><a href="http://thinkpython2.com/code/words.txt"><em>code</em></a><a href="http://thinkpython2.com/code/words.txt"><em>/</em></a><a href="http://thinkpython2.com/code/words.txt"><em>words</em></a><a href="http://thinkpython2.com/code/words.txt"><em>.</em></a><a href="http://thinkpython2.com/code/words.txt"><em>txt</em></a>
دریافت کنید.</p>
<p>این فایل متن خام است، بنابراین شما می‌توانید آنرا با یک ویرایشگر متنی
باز کنید، ولی همچنین می‌توانید آنرا از درون Python بخوانید. تابع درونی
(built-in) open نام فایل را به عنوان یک پارامتر می‌گیرد و یک شیء file
بر‌می‌گرداند که می‌توانید از آن برای خواندن فایل بهره ببرید.</p>
<p>&gt;&gt;&gt; fin = open('words.txt')</p>
<p>در این عبارت واژه fin یک نام رایج برای یک شیء file برای ورودی می باشد.
شیء file چندین روش برای خواندن، دربردارنده readline، فراهم می‌کند که
کاراکترها را از فایل تا زمانی که به یک newline برسد می‌خواند و نتیجه را
به عنوان یک رشته بر‌می‌گرداند.</p>
<p>&gt;&gt;&gt; fin.readline()</p>
<p>'aa\r\n'</p>
<p>نخستین واژه در این لیست خاص “aa” می باشد. دنباله \r\n دو کاراکتر فضای
خالی را نمایش می دهند، یک carriage return و یک newline، که این واژه را
از بعدی جدا می کند.</p>
<p>شیء file رد اینکه کجای فایل هستیم را نگه می دارد، بنابراین اگر دوباره
readline را صدا بزنید، می‌توانید واژه بعدی را بخوانید:</p>
<p>&gt;&gt;&gt; fin.readline()</p>
<p>'aah\r\n'</p>
<p>واژه بعدی “aah” است. اگر فضای خالی آزارتان می دهد، می‌توانید خود را از
دست آن با متد strip رشته برهانید:</p>
<p>&gt;&gt;&gt; line = fin.readline()</p>
<p>&gt;&gt;&gt; word = line.strip()</p>
<p>&gt;&gt;&gt; word</p>
<p>'aahed'</p>
<p>همچنین می‌توانید از شیء file به عنوانی بخشی از حلقه for بکار بگیرید. این
برنامه فایل words.txt را می‌خواند و همه واژه‌ها را چاپ می کند، هرکدام در
یک خط:</p>
<p>fin = open('words.txt')</p>
<p>for line in fin:</p>
<p>word = line.strip()</p>
<p>print(word)</p>
<h6 id="_3">#### <span id="anchor-3"></span><strong>۹.۲ تمرین ها</strong></h6>
<p>حل این تمرین‌ها در بخش بعدی آورده شده اند. بهتر است پیش از اینکه راه
حل‌ها را بخوانید برای هر کدام را دست کم یکبار تلاش کنید.</p>
<p>تمرین ۹.۱. برنامه‌ای بنویسید که فایل words.txt را می‌خواند و تنها
واژگانی را چاپ می‌کند که دارای بیش از ۲۰ حرف می‌باشند (بدون شمارش فضای
خالی).</p>
<p>تمرین ۹.۲. در سال ۱۹۳۹ ارنست وینسنت رایت یک رمان ۵۰،۰۰۰ واژه‌ای را منتشر
کرد که Gadsby نام دارد که دربردارنده حرف “e” نیست. چون “e” رایج ترین حرف
در انگلیسی است، کار آسانی نبوده است.</p>
<p>در واقع، ساخت یک اندیشه بدون بکار بردن رایج ترین نماد دشوار است. در آغاز
کند پیش می رود، ولی با احتیاط و ساعت‌ها آموزش می‌توانید کم کم روان شوید.</p>
<p>بسیار خب، دیگر ادامه نمی دهم.</p>
<p>یک تابع به نام has_no_e بنویسید که چنانچه واژه داده شده دارای حرف “e”
نباشد True برگرداند.</p>
<p>برنامه تان را از بخش پیشین به گونه‌ای اصلاح کنید که تنها واژگانی را چاپ
کند که هیچ “e” در آنها نیست و درصد واژگانی را که در لیست هیچ حرف “e”
ندارند را محاسبه کند.</p>
<p>تمرین ۹.۳. یک تابع به نام avoids بنویسید که یک واژه و یک رشته از حروف
ممنوعه را به عنوان پارامتر بگیرد و چنانچه آن واژه هیچ یک از حروف ممنوعه
را دربرنداشته باشد True برگرداند.</p>
<p>برنامه خود را به گونه‌ای اصلاح کنید که از کاربر بخواهد یک رشته از حروف
ممنوعه را وارد کند و سپس شمار واژگانی که هیچ یک از آنها ندارند چاپ کند.
آیا می‌توانید یک ترکیب از ۵ حروف ممنوعه را پیدا کنید که واژگان کمتری را
از رده خارج می کند.</p>
<p>تمرین ۹.۴. یک تابع به نام uses_only بنویسید که یک واژه و یک رشته از
حروف را به عنوان پارامتر می‌گیرد و چنانچه اگر آن واژه تنها دارای حروف در
آن رشته باشند True برگرداند. آیا می‌توانید یک جمله تنها با بکارگیری از
حروف acefhlo بسازید؟ بغیر “؟Hoe alfalfa“</p>
<p>تمرین ۹.۵. یک تابع به نام uses_all بنویسید که یک واژه و یک رشته از حروف
نیازمند را به عنوان پارامتر می‌گیرد و چنانچه اگر آن واژه همه آن حروف
مورد نیاز را دست کم یکبار بکار برده باشد True برگرداند. چند واژه هستند
که همه حروف صدا دارد aeiou را بکار برده اند؟ درباره aeiouy چگونه؟</p>
<p>تمرین ۹.۶. یک تابع به نام is_abecedarian بنویسید که چنانچه حروف در یک
واژه به ترتیب الفبایی باشند (حروف دوتایی اشکالی ندارد) True برگرداند.
چند واژه abecedarian وجود دارند؟</p>
<h6 id="_4">#### <span id="anchor-4"></span><strong>۹.۳ جستجو</strong></h6>
<p>همه تمرین‌های در بخش پیشین یک چیز مشترک دارند؛ آن‌ها می‌توانند با یک
الگوی جستجو که در بخش ۸.۶ دیدیم حل شوند. ساده‌ترین نمونه اینگونه است:</p>
<p>def has_no_e(word):</p>
<p>for letter in word:</p>
<p>if letter == 'e':</p>
<p>return False</p>
<p>return True</p>
<p>حلقه for کاراکترهای در واژه را پیمایش می کند. اگر ما حرف “e” را پیدا
کنیم، می‌توانیم بی درنگ False را برگردانیم؛ وگرنه ناگزیریم که به سراغ
حرف بعدی برویم. اگر ما از حلقه به گونه‌ای نرمال بیرون رویم، به معنای
آنست که ما یک “e” پیدا نکرده‌ایم، بنابراین True برمی‌گردانیم.</p>
<p>شما می‌توانید این تابع را با بکار بردن عملگر in کوتاهتر کنید، ولی من با
این نگارش آغاز کردم چونکه این منطق الگوی جستجو را نشان می دهد.</p>
<p>تابع avoids نگارش عمومی‌تر has_no_e می‌باشد ولی ساختار یکسانی دارد:</p>
<p>def avoids(word, forbidden):</p>
<p>for letter in word:</p>
<p>if letter in forbidden:</p>
<p>return False</p>
<p>return True</p>
<p>ما می‌توانیم به محض اینکه یک حرف ممنوعه پیدا کنیم False برگردانیم؛ اگر
به پایان حلقه برسیم True برمی‌گردانیم.</p>
<p>تابع uses_only نیز مشابه است بجز اینکه معنای شرط وارون است:</p>
<p>def uses_only(word, available):</p>
<p>for letter in word:</p>
<p>if letter not in available:</p>
<p>return False</p>
<p>return True</p>
<p>بجای پیمایش حروف ها در واژه، حلقه حروف مورد نیاز را پیمایش می کند. اگر
هریک از حروف مورد نیاز در واژه نیامده باشد، می‌توانیم False برگردانیم.</p>
<p>اگر شما همانند یک دانشمند کامپیوتر بیاندیشید، شاید پی برده باشید که
uses_all یک نمونه از مسأله حل شده پیشین بود، و اینگونه آنرا می نوشتید:</p>
<p>def uses_all(word, required):</p>
<p>return uses_only(required, word)</p>
<p>این یک مثال از برنامه‌ریزی توسعه برنامه که کاهش به مسأله حل شده پیشین
نام دارد، می‌باشد که به معنای این است که مسئله‌ای را که روی آن کار
می‌کنید به عنوان یک نمونه ازیک مسأله حل شده شناسایی می‌کنید و یک راه حل
موجود را به آن اعمال می کنید.</p>
<h6 id="_5">#### <span id="anchor-5"></span><strong>۹.۴ حلقه با اندیس ها</strong></h6>
<p>من تابع های در بخش پیشین را با حلقه های for نوشتم چونکه من تنها به
کاراکترهای در رشته‌ها نیاز داشتم؛ من هیچ کاری با اندیس ها نداشتم.</p>
<p>برای تابع is_abecedarian ما ناگزیریم که حروف مجاور را بسنجیم و مقایسه
کنیم، که کمی با حلقه for دشوار است:</p>
<p>def is_abecedarian(word):</p>
<p>previous = word[0]</p>
<p>for c in word:</p>
<p>if c &lt; previous:</p>
<p>return False</p>
<p>previous = c</p>
<p>return True</p>
<p>یک راه دیگر این است که از روش بازگشتی بهره ببریم:</p>
<p>def is_abecedarian(word):</p>
<p>if len(word) &lt;= 1:</p>
<p>return True</p>
<p>if word[0] &gt; word[1]:</p>
<p>return False</p>
<p>return is_abecedarian(word[1:])</p>
<p>گزینه دیگر بهره گیری از حلقه while است:</p>
<p>def is_abecedarian(word):</p>
<p>i = 0</p>
<p>while i &lt; len(word)-1:</p>
<p>if word[i+1] &lt; word[i]:</p>
<p>return False</p>
<p>i = i+1</p>
<p>return True</p>
<p>حلقه با i=0 آغاز می‌کند و هنگامی i=len(word)-1 پایان می یابد. در هر دور،
کاراکتر iام (که می‌توانید آنرا کاراکتر کنونی ببنید) را با کاراکتر i+1ام
(که می‌توانید بعدی ببینید) مقایسه می کند.</p>
<p>اگر کاراکتر بعدی کمتر از (از دید الفبایی پیش از) از کنونی باشد، آنگاه ما
یک شکست در ترند abecedarian یافته ایم، و False برمی‌گردانیم.</p>
<p>اگر ما به پایان حلقه بدون یافتن یک شکست برسیم، آنگاه آن واژه از آزمون
گذر می کند. برای اینکه خود را متقاعد کنید که حلقه به درستی پایان می
یابد، یک نمونه همانند ‘flossy’ را در لحاظ کنید. طول این واژه ۶ است،
بنابراین بار پایانی که حلقه اجرا می‌شود هنگامی است که I برابر ۴ می باشد،
که اندیس کاراکتر دوم از پایان می باشد. در دور پایانی، کاراکتر دوم از
پایان را با کاراکتر پایانی مقایسه می کند، که همانگونه می‌شود که می
خواهیم.</p>
<p>در اینجا نگارشی از is_palindrome (تمرین ۶.۳ را ببینید) آورده شده است که
از دو اندیس بهره می گیرد؛ یکی از ابتدا آغاز می‌کند و بالاتر می رود؛ و
دیگری از پایان آغاز می‌کند و پایین می آید.</p>
<p>def is_palindrome(word):</p>
<p>i = 0</p>
<p>j = len(word)-1</p>
<p>while i&lt;j:</p>
<p>if word[i] != word[j]:</p>
<p>return False</p>
<p>i = i+1</p>
<p>j = j-1</p>
<p>return True</p>
<p>یا اینکه می‌توانیم اینرا به یک مسأله حل شده پیشین کاهش دهیم و بنویسیم:</p>
<p>def is_palindrome(word):</p>
<p>return is_reverse(word, word)</p>
<h6 id="_6">#### <span id="anchor-6"></span><strong>۹.۵ اشکال زدایی</strong></h6>
<p>آزمودن برنامه‌ها دشوار است. آزمودن تابع های در این فصل نسبتاً آسان است
چونکه شما می‌توانید نتایج را دستی بررسی کنید. با این حال، این جایی میان
دشوار و ناممکن است که یک مجموعه از واژگان را برگزینید که برای همه خطاهای
ممکن تست کنید.</p>
<p>با در نظر گرفتن has_no_e برای نمونه، دو مورد نمایان هستند که باید
بررسی شوند: واژگانی که یک ‘e’ دارند باید False برگردانده شوند، و واژگانی
که ندارند باید True برگردانند. شما نباید هیچ دردسری برای هرکدام از
این‌ها داشته باشید.</p>
<p>درون هر مورد، زیر مورد های غیرنمایانی هستند. در میان واژگانی که یک “e”
دارند، بهتر است واژگانی را با یک “e” در آغاز، در پایان، و در جایی در
میانه تست کنید. بهتر است واژگان دراز، واژگان کوتاه، و واژگان خیلی کوتاه،
همانند رشته خالی را تست کنید. رشته خالی یک نمونه از یک <strong>حالت خاص</strong> است،
که یکی از حالت‌های غیر نمایان می‌باشد که در بیشتر موارد خطا درست می کند.</p>
<p>افزون بر موردهای آزمونی و تستی که خود می سازید، می‌توانید برنامه خود را
با یک فهرست واژه همچون words.txt بیازمایید. با پویش خروجی، خواهید توانست
که خطاها را دریابید، ولی مراقب باشید: شاید شما یک گونه از خطا را دریابید
(واژگانی که نباید شامل شوند، ولی هستند) و نه دیگری (واژگانی که باید
بیایند ولی نیامده اند).</p>
<p>به گونه کلی، آزمودن می‌تواند به شما کمک کند تا اشکالات (باگ ها) را پیدا
کنید، ولی تولید کردن یک مجموعه خوب از موارد تست (test cases) آسان نیست،
و هرچند اگر اینکار را انجام دهید، نمی‌توانید آسوده باشید که برنامه تان
درست است. برپایه یک دانشمند کامپیوتر افسانه ای:</p>
<p>میتوان از تست کردن برنامه بهره جست تا بودن اشکالات را نشان داد، ولی نه
هرگز برای نشان دادن نبودن آنها!</p>
<p>— Edsger W. Dijkstra</p>
<h6 id="_7">#### <span id="anchor-7"></span><strong>۹.۶ واژه نامه</strong></h6>
<p><strong>شیء فایل</strong> (file object): مقداری که یک فایل باز را نمایش می‌دهد.</p>
<p><strong>کاهش به یک مسئله حل شده پیشین</strong>: یک راه حل کردن یک مسئله با بیان کردن
آن به عنوان یک نمونه از یک مسئله حل شده پیشین.</p>
<p><strong>حالت خاص</strong>: یک مورد تست که ناشناخته یا غیرنمایان باشد (و شانس کمتری
برای مدیریت درست آن است).</p>
<h6 id="_8">#### <span id="anchor-8"></span><strong>تمرین‌ها ۹.۷</strong></h6>
<p>تمرین ۹.۷. این پرسش برپایه یک معماگو است که بر روی یک برنامه رادیویی Car
Talk
(<a href="http://www.cartalk.com/content/puzzler"><em>http</em></a><a href="http://www.cartalk.com/content/puzzler"><em>://</em></a><a href="http://www.cartalk.com/content/puzzler"><em>www</em></a><a href="http://www.cartalk.com/content/puzzler"><em>.</em></a><a href="http://www.cartalk.com/content/puzzler"><em>cartalk</em></a><a href="http://www.cartalk.com/content/puzzler"><em>.</em></a><a href="http://www.cartalk.com/content/puzzler"><em>com</em></a><a href="http://www.cartalk.com/content/puzzler"><em>/</em></a><a href="http://www.cartalk.com/content/puzzler"><em>content</em></a><a href="http://www.cartalk.com/content/puzzler"><em>/</em></a><a href="http://www.cartalk.com/content/puzzler"><em>puzzler</em></a>):</p>
<p>یک واژه با سه حرف دوتایی پشت سر هم به من دهید. من چند واژه به شما می‌دهم
که تقریباً به این مسئله می خورد، ولی اینکار را نکنید. برای نمونه، واژه
committee (c-o-m-m-i-t-t-e-e). این نمونه می‌توانست بسیار خوب باشد اگر که
‘i’ در میان آن سه نمی خزید. یا Mississippi: (M-i-s-s-i-s-s-i-p-p-i). اگر
می توانستید آن iها را بردارید به کارمان می آمد. ولی یک واژه است که سه
جفت حرف دوتایی پشت سرهم دارد و برپایه دانش من آن شاید تنها واژه‌ای با
این ویژگی باشد. البته شاید بیش از ۵۰۰ واژه به اینگونه باشد ولی من تنها
آنرا به یاد دارم. آن واژه چیست؟</p>
<p>یک برنامه بنویسید تا آنرا پیدا کند. راه حل:<a href="http://thinkpython2.com/code/cartalk1.py">
</a><a href="http://thinkpython2.com/code/cartalk1.py"><em>http</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>://</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>thinkpython</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>2.</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>com</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>/</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>code</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>/</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>cartalk</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>1.</em></a><a href="http://thinkpython2.com/code/cartalk1.py"><em>py</em></a>.</p>
<p>تمرین ۹.۸. در اینجا یه معمای دیگر از Car Talk آمده است که می‌توانید با
یک جستجو حل کنید
(<a href="http://www.cartalk.com/content/puzzlers"><em>http</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>://</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>www</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>.</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>cartalk</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>.</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>com</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>/</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>content</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>/</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>puzzlers</em></a>):</p>
<p>“به تازگی به دیدن مادرم رفتم و ما پی بردیم که دو رقمی که سن من را
می‌سازند هنگامی که وارون خوانده می‌شوند سن او را بدست می دهد. برای
نمونه، اگر سن او ۷۳ است، من ۳۷ سال می شوم. ما خواستیم بدانیم که چند بار
این رویداد در طی سالها رخ داده است ولی ما حواسمان با موضوع های دیگر پرت
شد و به پاسخ نرسیدیم.</p>
<p>هنگامی که به خانه رسیدم پی بردم که رقم های سن‌مان تا کنون ۶ بار وارون
پذیر بوده است. همچنین پی بردم که اگر خوش شانس باشیم به زودی بازهم در
چندسال دیگر رخ می دهد، و اگر واقعاً خوش شانس باشیم یکبار دیگر هم پس از
آن رخ خواهد داد. به گفته دیگر، روی هم رفته ۸ بار رخ می دهد. بنابراین
پرسش این است که من چند سال دارم؟“</p>
<p>یک برنامه پایتون بنویسید که برای راه حل‌های این معما جستجو کند.
راهنمایی: شاید متد zfill نوع رشته برای تان سودمند باشد.</p>
<p>راه حل:<a href="http://www.cartalk.com/content/puzzlers">
</a><a href="http://www.cartalk.com/content/puzzlers"><em>http</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>://</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>www</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>.</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>cartalk</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>.</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>com</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>/</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>content</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>/</em></a><a href="http://www.cartalk.com/content/puzzlers"><em>puzzlers</em></a></p>
				
				

			</div>

		</main>
	
		<footer class="oh">
		
			
			
			<a class="right" href="http://www.mkdocs.org">ساخته شده توسط: MkDocs.</a>

		</footer>
	
	</div>
	
	<!--
		To include static assets from our theme, just add
		.. beforehand which will be the relative path to
		the root of the documentation.
	-->
	<script src="../js/theme.js"></script>

	<!--
		extra_javascript contains paths to JavaScript files in the
		users documentation directory or a list of JavaScript files
		defined in their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_javascript
	-->
	

</body>
</html>