<!--
	This Basic theme serves as an example for how to create other
	themes by demonstrating the features with minimal HTML and CSS.
	Comments like this will be through the code to explain briefly
	what each feature is and point you to the MkDocs documentation
	to find out more.
-->
<!DOCTYPE html>
<head>
	
	<meta charset="UTF-8" />
	
	<!--
		The page_title contains the title for a page as shown in the navigation.
		Site name contains the name as defined in the mkdocs.yml
	-->
	<title>11 فصل یازدهم - تفکر پایتونی</title>

	<!--
		Support custom favicon support.
		http://www.mkdocs.org/user-guide/configuration/#site_favicon
	-->
	
		<link rel="shortcut icon" href="../img/favicon.ico">
	

	<!--
		You can include external assets of course, but be aware that it means the
		documentation may not work well offline.
	-->
	<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">

	<link rel="stylesheet" href="../css/theme.css">

	<!--
		extra_ess contains paths to CSS files in the users
		documentation directory or a list of CSS files defined in
		their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_css
	-->
	

	<link rel="stylesheet" href="../css/darkula.css">
	<script src="../js/highlight.pack.js"></script>
	
	<!--
		Include Google Analytics tracking code.

		http://www.mkdocs.org/user-guide/configuration/#google_analytics
	-->
	

	
	
</head>

<body>

	<div class="sidebar left">

		<ul>
		
			
				
				

	<li >
	
		<a href="..">Home</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../01-فصل اول/">01 فصل اول</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../02-فصل دوم/">02 فصل دوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../03-فصل سوم/">03 فصل سوم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../04-فصل چهارم/">04 فصل چهارم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../05-فصل پنجم/">05 فصل پنجم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../06-فصل ششم/">06 فصل ششم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../07-فصل هفتم/">07 فصل هفتم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../08-فصل هشتم/">08 فصل هشتم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../09-فصل نهم/">09 فصل نهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../10-فصل دهم/">10 فصل دهم</a>
		
	</li>


			
			
				
				

	<li class="active">
	
		<a href="./">11 فصل یازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../12-فصل دوازدهم/">12 فصل دوازدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../13-فصل سیزدهم/">13 فصل سیزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../14-فصل چهاردهم/">14 فصل چهاردهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../15-فصل پانزدهم/">15 فصل پانزدهم</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../16-فصل شانزده/">16 فصل شانزده</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../17-فصل هفده /">17 فصل هفده </a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../18-فصل هجده/">18 فصل هجده</a>
		
	</li>


			
			
				
				

	<li >
	
		<a href="../19-فصل نوزده/">19 فصل نوزده</a>
		
	</li>


			
			
		
		</ul>
		
	</div>
	
	<div class="body rel right">
	
		<header>
		
			<div class="right">
			
				<h1>11 فصل یازدهم - تفکر پایتونی</h1>
			
			</div>
		
			<div role="search" class="left">
			
				<form action="../search.html" class="rel" method="get">
				
					<input type="text" name="q" placeholder="جستجو" />
					
					<input type="submit" class="abs search-submit" value="" />
					
				</form>
				
			</div>
		
		</header>
		
		<main class="rel oh">
		
			
		
				<div class="left toc">
				
					<ul>
						
						
						
					</ul>
					
				</div>
			
			
			
			<div class="right content">
		
				
					
					<p><strong>فصل 11</strong></p>
<p><strong>دیکشنری ها</strong></p>
<p>این فصل یک نوع داخلی<a href="../built-in">^1</a> دیگر به نام دیکشنری را ارائه می کند. دیکشنری ها
یکی از بهترین ویژگی های پایتون هستند؛ آنها زیر بنای خیلی از الگوریتم های
کارآمد<a href="../efficient">^2</a> و ظریف<a href="../elegant">^3</a> هستند.</p>
<p>11. دیکشنری یک نگاشت<a href="../mapping">^4</a> است</p>
<p>دیکشنری مثل یک لیست هست اما عمومی تر. در لیست ها، اندیس ها باید عدد
صحیح<a href="../integers">^5</a> باشند؛ در یک دیکشنری آنها می توانند (تقریباً) هر نوعی باشند.</p>
<p>یک دیکشنری شامل مجموعه ای از اندیس هاست که به آنها <strong>کلید</strong><a href="../keys">^6</a> می گوییم
و مجموعه ای از مقادیر<a href="../values">^7</a>. هر کلید فقط به یک مقدار نسبت داده می شود. به
یک کلید و یک مقدار، <strong>زوج کلید-مقدار</strong>[^8] یا گاهی به آنها <strong>آیتم</strong><a href="../item">^9</a>
گفته می شود.</p>
<p>به زبان ریاضی، یک دیکشنری نشان دهنده یک نگاشت از کلید ها به مقدار هاست،
بنابراین می توان گفت هر کلید به یک مقدار «نگاشته می شود»<a href="../maps">^10</a>. به عنوان
مثال، ما یک دیکشنری خواهیم ساخت که کلمات انگلیسی را به اسپانیایی می
نگارد، بنابراین کلید ها و مقدار ها همه رشته<a href="../strings">^11</a> هستند.</p>
<p>تابع dict یک دیکشنری جدید بدون هیچ آیتی می سازد. به این دلیل که dict نام
یک تابع داخلی است، نباید از آن به عنوان اسم یک متغیر استفاده کنید.</p>
<p>&gt;&gt;&gt; eng2sp = dict()</p>
<p>&gt;&gt;&gt; eng2sp</p>
<p>{}</p>
<p>کروشه ها، {}، یک دیکشنری خالی رو نشان می دهند. برای اضافه کردن آیتم ها
به دیکشنری، می توانید از براکت استفاده کنید:</p>
<p>&gt;&gt;&gt; eng2sp['one'] = 'uno'</p>
<p>این خط یک آیتم می سازد که از کلید ‘one’ به مقدار ‘uno’ می نگارد. اگر ما
دیکشنری رو دوباره چاپ کنیم، یک زوج کلید-مقدار با یک دونقطه بین کلید و
مقدار می بینیم:</p>
<p>&gt;&gt;&gt; eng2sp</p>
<p>{'one': 'uno'}</p>
<p>این فرمت خروجی، یک فرمت ورودی نیز هست. برای مثال، می توانید یک دیکشنری
جدید با سه آیتم بسازید:</p>
<p>&gt;&gt;&gt; eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}</p>
<p>اما اگر eng2sp را چاپ کنید، ممکن است قافل گیر شوید:</p>
<p>&gt;&gt;&gt; eng2sp</p>
<p>{'one': 'uno', 'three': 'tres', 'two': 'dos'}</p>
<p>ترتیب زوج های کلید مقدار ممکن است یکسان نباشد. اگر همین مثال را در
کامپیوترتان تایپ کنید، ممکن است جواب متفاوتی بگیرید. عموماً، ترتیب آیتم
ها در یک دیکشنری غیر قابل پیش بینی است.</p>
<p>اما این مشکلی نیست، چون المان های یک دیکشنری هیچ گاه با اندیس های عدد
صحیح جستجو نمی شوند. بلکه به جای آن، از کلید ها برای جستجو مقادیر متناظر
استفاده می شود.</p>
<p>&gt;&gt;&gt; eng2sp['two']</p>
<p>'dos'</p>
<p>کلید ‘two’ همیشه به مقدار ‘dos’ نگاشته می شود بنابراین ترتیب آیتم ها مهم
نیست.</p>
<p>اگر آن کلید در دیکشنری نباشد، یک استثنا<a href="../exception">^12</a> می گیرید:</p>
<p>&gt;&gt;&gt; eng2sp['four']</p>
<p>KeyError: 'four'</p>
<p>تابع len بر روی دیکشنری ها کار می کند؛ تعداد زوج های کلید مقدار را بر می
گرداند.</p>
<p>&gt;&gt;&gt; len(eng2sp)</p>
<p>3</p>
<p>عملگرin نیز بر روی دیکشنری ها کار می کند. این عملگر به شما می گوید که
آیا چیزی به عنوان یک کلید در دیکشنری ظاهر شده است. (به عنوان مقدار ظاهر
شدن کافی نیست).</p>
<p>&gt;&gt;&gt; 'one' in eng2sp</p>
<p>True</p>
<p>&gt;&gt;&gt; 'uno' in eng2sp</p>
<p>False</p>
<p>برای اینکه ببینید چیزی به عنوان یک مقدار در دیکشنری ظاهر شده است، می
توانید از متد values استفاده کنید، که مجموعه ای از مقادیر را بر می
گرداند، و سپس از عملگر in استفاده کنید.</p>
<p>&gt;&gt;&gt; vals = eng2sp.values()</p>
<p>&gt;&gt;&gt; 'uno' in vals</p>
<p>True</p>
<p>عملگر in از الگوریتم های متفاوتی برای لیست ها و دیکشنری ها استفاده می
کند. برای لیست ها، المان های لیست را به ترتیب جستجوی می کند، مانند بخش
8.6. هر چه لیست طولانی تر باشد، زمان جستجو با نسبت مستقیم طولانی تر می
شود.</p>
<p>برای دیکشنری ها، پایتون از الگوریتمی به نام درهم ساز<a href="../hashtable">^13</a> که خصوصیت قابل
توجهی دارد: عمگر in بدون توجه به اینکه چند آیتم در دیکشنری است زمان
یکسانی طول می کشد. در بخش B.4 توضیح می دهم که چگونه چنین چیزی امکان پذیر
است، اما ممکن است توضیحات تا زمانی که چند فصل دیگر را نخوانید، قابل فهم
نباشد.</p>
<p><strong>11.2 دیکشنری به عنوان مجموعه ای از شمارنده ها</strong></p>
<p>فرض کنید رشته ای به شما داده شده است و می خواهید بشمرید چند بار هر حرف
تکرار شده است. راه های مختلفی برای انجام آن است:</p>
<ol>
<li>می توانید 26 متغیر بسازید، یکی برای هر حرف الفبا. بعد می توانید رشته
    را پیشمایش کنید، برای هر کاراکتر، شمارنده متناظر با آن را افزایش
    دهید، احتمالاً از شرط های پشت سر هم استفاده کنید.</li>
<li>می توانید یک لیست با 26 المان درست کنید. بعد می توانید هر کاراکتر را
    به یک عدد تبدیل کنید(با استفاده از تابع داخلی ord)، از عدد به عنوان
    یک اندیس برای لیست استفاده کنید، و شمارنده مناسب را افزایش دهید.</li>
<li>می توانید یک دیکشنری با کاراکتر ها به عنوان کلید ها و شمارنده ها به
    عنوان مقدار های متناظراستفاده کنید. اولین باری که یک کاراکتر را می
    بینید، یک آیتم به دیکشنری اضافه می کنید. بعد از آن مقدار آیتمی که
    وجود دارد را اضافه می کنید.</li>
</ol>
<p>هر کدام از این گزینه ها محاسبات یکسانی را انجام می دهند، اما هر کدام این
محاسبات را به روش متفاوتی پیاده سازی می کنند:</p>
<p>یک <strong>پیاده سازی</strong><a href="../implementation">^14</a><strong> </strong>راهی برای انجام یک محاسبه<a href="../computation">^15</a> است؛ بعضی از
پیاده سازی ها بهتر از پیاده سازی های دیگر هستند. به عنوان مثال، یک مزیت
پیاده سازی دیکشنری این است که نیازی نیست که از قبل بدانیم کدام حرف ها در
رشته ظاهر شده اند و فقط نیاز است که برای حرف هایی که ظاهر می شوند فضا
اختصاص بدهیم.</p>
<p>کد مورد نظر به شکل زیر خواهد بود:</p>
<p>def histogram(s):</p>
<p>d = dict()</p>
<p>for c in s:</p>
<p>if c not in d:</p>
<p>d[c] = 1</p>
<p>else:</p>
<p>d[c] += 1</p>
<p>return d</p>
<p>اسم تابع histogram است، که یک اصطلاح آماری برای یک مجموعه شمارنده(یا
فراوانی) است.</p>
<p>اولین خط تابع یک دیکشنری خالی می سازد. حلقه for رشته را می پیماید. هر
بار در حلقه، اگر کاراکتر c در دیکشنری نباشد، یک آیتم جدید با کلید c و
مقدار اولیه 1 می سازیم. اگر c پیش از این در دیکشنری است d[c] را افزایش
می دهیم.</p>
<p>به اینصورت کار می کند:</p>
<p>&gt;&gt;&gt; h = histogram('brontosaurus')</p>
<p>&gt;&gt;&gt; h</p>
<p>{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}</p>
<p>هیستوگرام نشان می دهد که حرف های ‘a’ و ‘b’ یکبار تکرار شده اند. ‘o’
دوبار ظاهر شده است و....</p>
<p>دیکشنری ها متدی به نام get دارند که یک کلید و یک مقدار پیش فرض می گیرد.
اگر کلید در دیکشنری باشد، get مقدار متناظر را برمی گرداند. در غیر
اینصورت مقدار پیش فرض را بر می گرداند. برای مثال:</p>
<p>&gt;&gt;&gt; h = histogram('a')</p>
<p>&gt;&gt;&gt; h</p>
<p>{'a': 1}</p>
<p>&gt;&gt;&gt; h.get('a', 0)</p>
<p>1</p>
<p>&gt;&gt;&gt; h.get('b', 0)</p>
<p>0</p>
<p>به عنوان تمرین، از get برای نوشتن histogram به صورت خلاصه تر استفاده
کنید. باید بتوانید که دستور if را حذف کنید.</p>
<p>11.3 حلقه ها و دیکشنری ها</p>
<p>اگر از یک دیکشنری در دستور for استفاده کنید، کلید های دیکشنری را پیمایش
می کند. برای مثال، print_hist هر کلید و مقدار متناظر را چاپ می کند:</p>
<p>def print_hist(h):</p>
<p>for c in h:</p>
<p>print(c, h[c])</p>
<p>خروجی به صورت زیر خواهد بود:</p>
<p>&gt;&gt;&gt; h = histogram('parrot')</p>
<p>&gt;&gt;&gt; print_hist(h)</p>
<p>a 1</p>
<p>p 1</p>
<p>r 2</p>
<p>t 1</p>
<p>o 1</p>
<p>دوباره، کلید ها هیچ ترتیب خاصی ندارند. دیکشنری ها متدی به نام keys دارند
که کلید های دیکشنری را بدون هیچ ترتیب خاصی، به صورت یک لیست برمی گرداند.
به عنوان تمرین، print_hist را تغییر دهید تا کلید ها و مقدارهای آنها را
به ترتیب حروف الفبا چاپ کند.</p>
<p><strong>11.4 جستجوی معکوس</strong></p>
<p>با یک دیکشنری d و یک کلید k، پیدا کردن مقدار متناظر d[k] = v آسان است.
این عمل یک جستجو<a href="../lookup">^16</a> نامیده می شود.</p>
<p>اما اگر v را داشته باشید و بخواهید k را پیدا کنید چه می کنید؟ دو مشکل
دارید: اولاً، ممکن است بیشتر از یک کلید باشد که به مقدار v نگاشته شود.
بر حسب کاربرد، ممکن است که بتوانید یکی را انتخاب کنید، یا ممکن است نیاز
باشد که لیستی بسازید که شامل همه آنها باشد. دوماً، هیچ ساختار ساده ای
برای انجام یک <strong>جستجو مکعوس</strong>[^17]<strong> </strong>وجود ندارد. باید جستجو کنید.</p>
<p>تابع زیر یک مقدار می گیرد و اولین کلیدی که به آن مقدار نگاشته می شود بر
می گرداند:</p>
<p>def reverse_lookup(d, v):</p>
<p>for k in d:</p>
<p>if d[k] == v:</p>
<p>return k</p>
<p>raise LookupError()</p>
<p>این تابع مثال دیگری از الگوی جستجو است، اما از ویژگی استفاده می کند که
ما قبلاً ندیده ایم، raise. دستور raise یک استثنا ایجاد می کند؛ در این
مورد موجب یک LookupError می شود، که یک استثنا داخلی است که برای نشان
دادن شکست یک عمل جستجو، استفاده می شود.</p>
<p>اگر به آخر حلقه برسیم، به این معنی است که v در داخل دیکشنری به عنوان
مقدار وجود ندارد، بنابراین یک استثنا بر می انگیزیم[^18].</p>
<p>این یک مثال از یک جستجو معکوس موفق است:</p>
<p>&gt;&gt;&gt; h = histogram('parrot')</p>
<p>&gt;&gt;&gt; k = reverse_lookup(h, 2)</p>
<p>&gt;&gt;&gt; k</p>
<p>'r'</p>
<p>و یک جستجوی غیر موفق:</p>
<p>&gt;&gt;&gt; k = reverse_lookup(h, 3)</p>
<p>Traceback (most recent call last):</p>
<p>File "&lt;stdin&gt;", line 1, in &lt;module&gt;</p>
<p>File "&lt;stdin&gt;", line 5, in reverse_lookup</p>
<p>ValueError</p>
<p>تاثیر برانگیختن استثنا به همانند زمانی است که پایتون بر می انگیزد: یک
ردیابی<a href="../traceback">^19</a> و یک پیام خطا چاپ می کند.</p>
<p>دستور raise می تواند یک پیام خطا دقیق به عنوان آرگومان اختیاری بگیرد.
برای مثال:</p>
<p>&gt;&gt;&gt; raise ValueError('value does not appear in the dictionary')</p>
<p>Traceback (most recent call last):</p>
<p>File "&lt;stdin&gt;", line 1, in ?</p>
<p>ValueError: value does not appear in the dictionary</p>
<p>یک جستجو معکوس خیلی کند تر از یک جستجو (مستقیم<a href="../forward-lookup">^20</a>) است؛ اگر باید اغلب
آن را انجام دهید، یا اگر دیکشنری بزرگ شود، کارایی برنامتان کم خواهد شد.</p>
<p>11.5<strong> دیکشنری و لیست ها</strong></p>
<p>لیست ها می توانند به عنوان مقدار ها در دیکشنری ها ظاهر شوند. برای مثال،
اگر یک دیکشنری به شما داده شود که حرف ها را به تعداد می نگارد، شاید شما
بخواهید که بر عکسش کنید؛ یعنی، بخواهید یک دیکشنری بسازید که تعداد تکرار
را به حرف ها می نگارد. به این دلیل که ممکن است حرف های زیادی با تعداد
تکرار یکسان باشند، هر مقدار در دیکشنری معکوس باید لیستی از حرف ها باشد.</p>
<p>تابع زیر یک دیکشنری را معکوس می کند:</p>
<p>def invert_dict(d):</p>
<p>inverse = dict()</p>
<p>for key in d:</p>
<p>val = d[key]</p>
<p>if val not in inverse:</p>
<p>inverse[val] = [key]</p>
<p>else:</p>
<p>inverse[val].append(key)</p>
<p>return inverse</p>
<p>هر بار در حلقه، key یک کلید از d و val مقدار متناظر آن را می گیرد. اگر
val در inverse نباشد، به این معنی است که ما قبلاً آن را ندیده ایم،
بنابراین، یک آیتم جدید می سازیم و با یک یگانه<a href="../لیستی با یک المان">^21</a>
مقدار دهی اولیه می کنیم. در غیر اینصورت ما این مقدار را قبلاً دیده ایم،
بنابراین کلید متناظر با آن را به لسیت اضافه می کنیم.</p>
<p>به عنوان مثال:</p>
<p>&gt;&gt;&gt; hist = histogram('parrot')</p>
<p>&gt;&gt;&gt; hist</p>
<p>شکل 11.1 نمودار حالت</p>
<p>{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}</p>
<p>&gt;&gt;&gt; inverse = invert_dict(hist)</p>
<p>&gt;&gt;&gt; inverse</p>
<p>{1: ['a', 'p', 't', 'o'], 2: ['r']}</p>
<p>شکل 11.1 یک نمودار حالت است که hist و inverse را نمایش می دهد. یک
دیکشنری به عنوان یک جعبه با نوع type بالای آن و زوج های کلید مقدار درون
آن نمایش داده شده است. اگر مقدار ها عدد صحیح هستند، اعشاری یا رشته، آنها
را درون جعبه می کشم، اما معمولاً لیست ها را بیرون جعبه می کشم تا نمودار
ساده باشد.</p>
<p>لیست ها می توانند مقدار های درون یک دیکشنری باشند، همانطور که این مثال
نشان می دهد، اما نمی توانند کلید باشند. اگر امتحان کنید این اتفاق می
افتد:</p>
<p>&gt;&gt;&gt; t = [1, 2, 3]</p>
<p>&gt;&gt;&gt; d = dict()</p>
<p>&gt;&gt;&gt; d[t] = 'oops'</p>
<p>Traceback (most recent call last):</p>
<p>File "&lt;stdin&gt;", line 1, in ?</p>
<p>TypeError: list objects are unhashable</p>
<p>من قبلاً گفته ام که یک دیکشنری با استفاده از یک درهم ساز پیاده سازی می
شود و آن به این معنی است که کلید ها باید <strong>قابل درهم سازی</strong><a href="../hashable">^22</a> باشد.</p>
<p>یک <strong>درهم ساز</strong><a href="../hash">^23</a> تابعی است که یک مقدار(از هر نوعی) می گیرد و یک عدد
صحیح برمی گرداند. دیکشنری ها از این عدد صحیح ها که به آنها مقدار درهم
ساز گفته می شود برای ذخیره سازی و جستجو زوج کلید مقدار ها استفاده می
کنند.</p>
<p>این سیستم اگر کلید ها غیر قابل تغییر<a href="../immutable">^24</a> باشند به خوبی کار می کند. اما
اگر کلید ها قابل تغییر<a href="../mutable">^25</a> باشند، مانند لیست ها، اتفاق های بدی می افتد.
برای مثال، وقتی یک زوج کلید مقدار می سازید، پایتون کلید را درهم سازی می
کند و در جایگاه متناظر ذخیره می کند. اگر کلید را تغییر دهید و دوباره آن
را درهم سازی کنید، به جای متفاوتی خواهد رفت. در اینصورت ممکن است دو
ورودی برای کلید یکسان داشته باشید، یا ممکن است نتوانید کلید را پیدا
کنید. در هر صورت، دیکشنری درست کار نخواهد کرد.</p>
<p>به همین دلیل است که کلید ها باید قابل درهم سازی باشند، و به همین دلیل
است که نوع های قابل تغییر مانند لیست قابل درهم سازی نیستند. ساده ترین
راه برای رفع این محدودیت استفاده از چندتایی<a href="../tuple">^26</a> ها است، که در فصل بعد
می بینید.</p>
<p>به این دلیل که دیکشنری ها قابل تغییر هستند، به عنوان کلید نمی توان از
آنها استفاده کرد، اما از آنها می توان به عنوان مقدار استفاده کرد.</p>
<p>11.6 یادداشت ها</p>
<p>اگر با تابع fibonacci از بخش 6.7 کارکرده اید، ممکن است متوجه شده باشید
که هر چه آرگومان بزرگتری ارائه کنید، تابع زمان طولانی تری برای اجرا
خواهد گرفت. علاوه بر این، زمان اجرا به سرعت زیاد می شود.</p>
<p>شکل 11.2: گراف فراخوانی</p>
<p>برای اینکه بفهمیم چرا، شکل 11.2 را در نظر بگیرید که گراف فراخوانی[^27]
را برای fibonacci با n=4 نمایش می دهد:</p>
<p>یک گراف فراخوانی مجموعه ای از فریم های تابع را نمایش می دهد. خط ها هر
فریم تابع را به فریم های تابع هایی که فراخوانی می کند، وصل می کنند. در
بالای گراف، fibonacci با n=4 تابع fibonacci با n=3 و n=2 را فراخوانی می
کند. به همین منوال fibonacci با n=3 تابع fibonacci با n=2 و n=1 را
فراخوانی می کند. و به همین ترتیب ادامه دارد.</p>
<p>بشمارید چند بار تابع های fibonacci(0) و fibonacci(1) فراخوانی می شوند.
این یک راه حل ناکارامد برای این مساله است، و با بزرگ تر شدن آرگومان ها
بدتر هم می شود.</p>
<p>یک راه حل، پیگیری متغیر های که تا حالا محاسبه شده اند با ذخیره سازی آنها
در یک دیکشنری است. به یک مقدار که قبلا محاسبه شده و برای استفاده های
بعدی ذخیره می شود، <strong>یادداشت</strong><a href="../memo">^28</a><strong> </strong> می گویند.</p>
<p>یک نسخه یادداشت گذاری شده<a href="../memoized">^29</a> تابع fibonacci در زیر آمده است:</p>
<p>known = {0:0, 1:1}</p>
<p>def fibonacci(n):</p>
<p>if n in known:</p>
<p>return known[n]</p>
<p>res = fibonacci(n-1) + fibonacci(n-2)</p>
<p>known[n] = res</p>
<p>return res</p>
<p>known یک دیکشنری است که اعداد فیبوناتچی که ما تاکنون می دانیم را ذخیره
می کند. با دو آیتم شروع می شود: 0 به 0 نگاشته می شود و 1 به 1 نگاشته می
شود.</p>
<p>هر زمان که fibonacci فراخوانی می شود، known را چک می کند. اگر نتایج
تاکنون در آنجا باشند، می تواند بلافاصله برگردد. در غیر اینصورت باید
مقدار جدید را محاسبه کند، آن را به دیکشنری اضافه کند و آن را برگرداند.</p>
<p>اگر این نسخه fibonacci را اجرا کنید و با نسخه اصلی مقایسه کنید، می بینید
که بسیار سریع تر است.</p>
<p>11.7 متغیر های سراسری[^30]</p>
<p>در مثال قبلی، known بیرون تابع تعریف شده است بنابراین متعلق به فریم خاصی
به نام __main__ است. متغیر های درون __main__ گاهی سراسری خوانده
می شوند به این دلیل که از هر تابعی می توان به آنها دسترسی پیدا کرد. بر
خلاف متغیر های محلی، که هنگامی که تابع آنها تمام می شود، ناپدید می شوند،
متغیر های سراسری از یک فراخوانی تابعی به فراخوانی تابعی دیگر باقی می
مانند. مرسوم است که از متغیر های سراسری برای پرچم ها<a href="../flags">^31</a> استفاده شود.
یعنی متغیر های بولی که (مانند پرچمی هستند که) نشان می دهند که آیا یک شرط
درست است یا خیر. برای مثال، بعضی از برنامه ها از پرچمی به نام verbose
استفاده می کنند تا میزان جزئیات در خروجی را کنترل کنند.</p>
<p>verbose = True</p>
<p>def example1():</p>
<p>if verbose:</p>
<p>print('Running example1')</p>
<p>اگر سعی کنید یک متغیر سراسری را مقدار دهی مجدد کنید، ممکن است غافلگیر
شوید. از مثال پایین انتظار می رود که پیگیری کند که آیا تابع فراخوانی شده
است یا خیر.</p>
<p>been_called = False</p>
<p>def example2():</p>
<p>been_called = True # WRONG</p>
<p>اما اگر اجرایش کنید، می بینید که مقدار been_called تغییر نمی کند. مشکل
این است که example2 یک متغیر محلی جدید به نام been_called می سازد.
متغیر محلی وقتی تابع تمام می شود از بین می رود و هیچ تاثیری بر روی متغیر
سراسری ندارد.</p>
<p>برای مقدار دهی مجدد یک متغیر سراسری درون یک تابع باید متغیر سراسری را
قبل استفاده اعلام<a href="../declare">^32</a> کنید.</p>
<p>been_called = False</p>
<p>def example2():</p>
<p>global been_called</p>
<p>been_called = True</p>
<p>دستور global به مفسر چیزی شبیه این جمله می گوید: «در این تابع، وقتی می
گویم been_called، منظورم آن متغیر سراسری است، یک متغیر محلی نساز.»</p>
<p>یک مثال که سعی می کند یک متغیر سراسری را به روز رسانی کند:</p>
<p>count = 0</p>
<p>def example3():</p>
<p>count = count + 1 # WRONG</p>
<p>اگر اجرایش کنید خطای زیر را می گیرید:</p>
<p>UnboundLocalError: local variable 'count' referenced before assignment</p>
<p>پایتون فرض می کند که متغیر count محلی است، و با آن فرض شما قبل از نوشتن
آن، آن را می خوانید. راه حل، باز، اعلام کردن count به عنوان یک متغیر
سراسری است.</p>
<p>def example3():</p>
<p>global count</p>
<p>count += 1</p>
<p>اگر یک متغیر سراسری به یک مقدار تغییر پذیر<a href="../mutable">^33</a> رجوع می کند، شما می
توانید آن مقدار را بدون اعلام کردن آن متغیر تغییر دهید:</p>
<p>known = {0:0, 1:1}</p>
<p>def example4():</p>
<p>known[2] = 1</p>
<p>بنابراین شما می توانید المان های یک لیست یا دیکشنری سراسری را اضافه، حذف
یا جایگزین کنید. اما اگر بخواهید متغیر را نسبت دهی مجدد کنید، باید
اعلامش کنید.</p>
<p>def example5():</p>
<p>global known</p>
<p>known = dict()</p>
<p>متغیر های سراسری می توانند مفید باشند، اما اگر تعداد زیادی از آنها را
داشته باشید، و مکررا آنها را تغییر دهید، ممکن است باعث شوند که اشکال
زدایی<a href="../debug">^34</a> برنامه سخت شود.</p>
<p><strong>11.8 اشکال زدایی</strong></p>
<p>همینطور که با مجموعه داده های بزرگتر کار می کنید، ممکن است اشکال زدایی
با چاپ کردن و چک کردن دستی خروجی، سنگین شود. چند پیشنهاد برای اشکال
زدایی مجموعه داده های بزرگ:</p>
<p><strong>مقیاس ورودی را کم کنید:</strong> اگر امکان دارد، سایز مجموعه داده را کم کنید.
برای مثال اگر برنامه یک فایل متنی را می خواند، فقط با 10 خط اول شروع
کنید، یا با کوچکترین مثالی که می توانید پیدا کنید. شما می توانید یا خود
فایل ها را ویرایش کنید، یا (بهتر از آن) برنامه را به نحوی تغییر دهید که
فقط n خط اول ورودی را می خواند.</p>
<p>اگر خطایی باشد، می توانید n را به کمترین مقداری که خطا را آشکار می کند
تغییر دهید، و سپس آن را بتدریج حین یافتن و تصحیح خطا ها، زیاد کنید.</p>
<p><strong>خلاصه ها و نوع ها را چک کنید: </strong>به جای چاپ کردن و چک کردن کل مجموعه
داده، چاپ کردن خلاصه داده ها را در نظر بگیرید: برای مثال، تعداد آیتم های
درون یک دیکشنری یا مجموع یک لیست اعداد.</p>
<p>یک علت شایع خطا های زمان اجرا، مقداری است که از نوع درست نیست. برای
اشکال زدایی این نوع از خطا ها، معمولا چاپ کردن نوع آن مقدار کافی است.</p>
<p><strong>خود بررسی</strong><a href="../self-check">^35</a><strong> بنویسید: </strong>بعضی از اوقات می توانید کدی بنویسید که
به صورت خودکار خطاها را چک کند. برای مثال، اگر میانگین لیستی از اعداد را
حساب می کنید، می توانید چک کنید که حاصل بزرگتر از بزرگترین المان، یا
کوچکتر از کوچکترین المان لیست نیست. به این روش</p>
<p>«بررسی سلامت»[^36] می گویند به این دلیل که نتایجی که «مشکل سلامتی»<a href="../insane">^37</a>
دارند پیدا می کند.</p>
<p>نوع دیگری از بررسی، نتایج دو محاسبه متفاوت را با هم مقایسه می کند تا
ببیند که آیا سازگار هستند. به این روش «بررسی سازگاری[^38]» می گویند.</p>
<p><strong>خروجی را فرمت کنید: </strong>فرمت کردن خروجی، می تواند پیدا کردن خطاها را
ساده تر کند. مثالی در بخش 6.9 دیدیم. ماژول pprint تابع pprint را فراهم
می کند که نوع های درونی را به فرمتی که برای انسان راحتر خوانده شود نمایش
می دهد. (pprint مخفف pretty print به معنی چاپ زیبا است.)</p>
<p>دوباره، زمانی که صرف سکوب بندی می کنید، می تواند زمانی که صرف اشکال
زدایی می کنید را کاهش دهد.</p>
<p><strong>11.9 واژه نامه</strong></p>
<p><strong>نگاشت:</strong> رابطه ای که هر المان یک مجموعه به یک المان یک مجموعه دیگر
مربوط می شود.</p>
<p><strong>دیکشنری:</strong> نگاشتی از کلید ها به مقدار های متناظر آنها.</p>
<p><strong>زوج کلید-مقدار:</strong> نمایش نگاشت از یک کلید به یک مقدار.</p>
<p><strong>آیتم: </strong>در یک دیکشنری، نامی دیگر برای یک زوج کلید مقدار.</p>
<p><strong>کلید:</strong> شی ای که در یک دیکشنری به عنوان قسمت اول یک زوج کلید مقدار
ظاهر می شود.</p>
<p><strong>مفدار: </strong>شی ای که در یک دیکشنری به عنوان قسمت دوم یک زوج کلید مفدار
ظاهر می شود. این استفاده از استفاده قبلی ما از کلمه «مقدار» خاص تر است.</p>
<p><strong>پیاده سازی: </strong>روشی برای انجام محاسبات</p>
<p><strong>جدول درهم سازی: </strong>الگوریتمی که برای ساختن دیکشنری های پایتون استفاده
شده است.</p>
<p><span id="anchor"></span><strong>تابع درهم ساز: </strong>تابعی که توسط یک جدول درهم
سازی برای محاسبه مکان یک کلید استفاده می شود.</p>
<p>[^8]:  key-value pair</p>
<p>[^17]:  reverse lookup</p>
<p>[^18]:  raise an exception</p>
<p>[^27]:  call graph</p>
<p>[^30]:  Global Variables</p>
<p>[^36]:  sanity check</p>
<p>[^38]:  consistency check</p>
				
				

			</div>

		</main>
	
		<footer class="oh">
		
			
			
			<a class="right" href="http://www.mkdocs.org">ساخته شده توسط: MkDocs.</a>

		</footer>
	
	</div>
	
	<!--
		To include static assets from our theme, just add
		.. beforehand which will be the relative path to
		the root of the documentation.
	-->
	<script src="../js/theme.js"></script>

	<!--
		extra_javascript contains paths to JavaScript files in the
		users documentation directory or a list of JavaScript files
		defined in their mkdocs.yml.

		http://www.mkdocs.org/user-guide/configuration/#extra_javascript
	-->
	

</body>
</html>